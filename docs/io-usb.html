<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='http://fonts.googleapis.com/css?family=Raleway:400,600,900' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'>

<!-- CSS -->
<title>Module libusb</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield
*/
/* SCSS variables */
/* Text weights */
/* Body colors */
/* Text colors */
/* Link colors */
/* Syntax highlighting colors */
/* Pct changes */
/* Mixins */
/* Body/layout */
html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

/* Where we want fancier font if available */
h1, h2, h3, h4, h5, h6, p.module-desc, table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important; }

h1.title {
  font-weight: 900; }

body {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 14px;
  line-height: 20px;
  color: #2d2d2d;
  background-color: rgba(252, 248, 244, 0.75); }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 100%;
    padding: 0; } }
/* For devices larger than 650px */
@media (min-width: 650px) {
  .container {
    width: 100%; }

  .column,
  .columns {
    margin-left: 4%; }

  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns {
    width: 4.66666666667%; }

  .two.columns {
    width: 13.3333333333%; }

  .three.columns {
    width: 22%; }

  .four.columns {
    width: 30.6666666667%; }

  .five.columns {
    width: 39.3333333333%; }

  .six.columns {
    width: 48%; }

  .seven.columns {
    width: 56.6666666667%; }

  .eight.columns {
    width: 65.3333333333%; }

  .nine.columns {
    width: 74.0%; }

  .ten.columns {
    width: 82.6666666667%; }

  .eleven.columns {
    width: 91.3333333333%; }

  .twelve.columns {
    width: 100%;
    margin-left: 0; }

  .one-third.column {
    width: 30.6666666667%; }

  .two-thirds.column {
    width: 65.3333333333%; } }
/* Customer Overrides */
.footer {
  text-align: center;
  color: #969696;
  padding-top: 10%; }

p.module-desc {
  font-size: 1.1em;
  color: #666666; }

a.link-seesrc {
  color: #aec7d2;
  font-style: italic; }

a.link-seesrc:hover {
  color: #6c9aae; }

#toc-list {
  word-wrap: break-word; }

ul.simple-toc {
  list-style: none; }

ul.simple-toc a.reference-toplevel {
  font-weight: bold;
  color: #0077b3; }

ul.simple-toc-section {
  list-style-type: circle;
  color: #6c9aae; }

ul.simple-toc-section a.reference {
  color: #0077b3; }

cite {
  font-style: italic !important; }

dt > pre {
  border-color: rgba(0, 0, 0, 0.15);
  background-color: transparent;
  margin: 15px 0px 5px; }

dd > pre {
  border-color: rgba(0, 0, 0, 0.1);
  background-color: whitesmoke;
  margin-top: 8px; }

.item > dd {
  margin-left: 10px;
  margin-bottom: 30px; }

/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: whitesmoke;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }

/* Docgen styles */
/* Links */
a {
  color: #0077b3;
  text-decoration: none; }

a:hover,
a:focus {
  color: #00334d;
  text-decoration: underline; }

a:visited {
  color: #00334d; }

a:focus {
  outline: thin dotted #2d2d2d;
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px; }

a:hover,
a:active {
  outline: 0; }

sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; } }
.img-rounded {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.img-polaroid {
  padding: 4px;
  background-color: rgba(252, 248, 244, 0.75);
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }

p {
  margin: 0 0 12px; }

small {
  font-size: 85%; }

strong {
  font-weight: 600; }

em {
  font-style: italic; }

cite {
  font-style: normal; }

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: 600;
  line-height: 20px;
  color: inherit;
  text-rendering: optimizelegibility; }

h1 {
  font-size: 2em;
  padding-bottom: .15em;
  border-bottom: 1px solid #aaaaaa;
  margin-top: 1.25em;
  line-height: 1.2em; }

h1.title {
  border-bottom: 0px;
  font-size: 2.75em;
  margin: 0.5em 0 1em 0; }

h2 {
  font-size: 1.5em;
  margin-top: 1.5em; }

h3 {
  font-size: 1.3em;
  font-style: italic;
  margin-top: 0.75em; }

h4 {
  font-size: 1.3em;
  margin-top: 0.5em; }

h5 {
  font-size: 1.2em;
  margin-top: 0.25em; }

h6 {
  font-size: 1.1em; }

ul,
ol {
  padding: 0;
  margin: 0 0 0px 15px; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0; }

li {
  line-height: 20px; }

dl {
  margin-top: 10px;
  margin-bottom: 20px; }

dt,
dd {
  line-height: 20px; }

dt {
  font-weight: 600; }

dd {
  margin-left: 10px;
  margin-bottom: 26px; }

hr {
  margin: 20px 0;
  border: 0;
  border-bottom: 1px solid #aaaaaa; }

abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #999999; }

abbr.initialism {
  font-size: 90%;
  text-transform: uppercase; }

blockquote {
  padding: 0 0 0 15px;
  margin: 0 0 20px;
  border-left: 5px solid #EFEBE0; }

table.docinfo + blockquote, table.docinfo blockquote, h1 + blockquote {
  border-left: 5px solid #c9c9c9;
}

table.docinfo + blockquote p, table.docinfo blockquote p, h1 + blockquote p {
  margin-bottom: 0;
  font-size: 15px;
  font-weight: 200;
  line-height: 1.5;
  font-style: italic; }

q:before,
q:after,
blockquote:before,
blockquote:after {
  content: ""; }

address {
  display: block;
  margin-bottom: 20px;
  font-style: normal;
  line-height: 20px; }

code,
pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  padding: 0 3px 2px;
  font-weight: 500;
  font-size: 12px;
  color: #444444;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px; }

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 600;
  /*color: #504da6;*/
}

code {
  padding: 2px 4px;
  color: #444444;
  white-space: nowrap;
  background-color: white;
  border: 1px solid #777777; }

pre {
  display: inline-block;
  box-sizing: border-box;
  min-width: calc(100% - 19.5px);
  padding: 9.5px;
  margin: 0 10px 0px 10px;
  font-size: 14px;
  line-height: 20px;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: whitesmoke;
  border: 1px solid #cccccc;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

pre.prettyprint {
  margin-bottom: 20px; }

pre code {
  padding: 0;
  color: inherit;
  white-space: pre;
  overflow-x: visible;
  background-color: transparent;
  border: 0; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }

table {
  max-width: 100%;
  background-color: transparent;
  border-collapse: collapse;
  border-spacing: 0; }

table th, table td {
  padding: 0px 8px 0px;
}

.table {
  width: 100%;
  margin-bottom: 20px; }

.table th,
.table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #444444; }

.table th {
  font-weight: bold; }

.table thead th {
  vertical-align: bottom; }

.table caption + thead tr:first-child th,
.table caption + thead tr:first-child td,
.table colgroup + thead tr:first-child th,
.table colgroup + thead tr:first-child td,
.table thead:first-child tr:first-child th,
.table thead:first-child tr:first-child td {
  border-top: 0; }

.table tbody + tbody {
  border-top: 2px solid #444444; }

.table .table {
  background-color: rgba(252, 248, 244, 0.75); }

.table-condensed th,
.table-condensed td {
  padding: 4px 5px; }

.table-bordered {
  border: 1px solid #444444;
  border-collapse: separate;
  *border-collapse: collapse;
  border-left: 0;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px; }

.table-bordered th,
.table-bordered td {
  border-left: 1px solid #444444; }

.table-bordered caption + thead tr:first-child th,
.table-bordered caption + tbody tr:first-child th,
.table-bordered caption + tbody tr:first-child td,
.table-bordered colgroup + thead tr:first-child th,
.table-bordered colgroup + tbody tr:first-child th,
.table-bordered colgroup + tbody tr:first-child td,
.table-bordered thead:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child th,
.table-bordered tbody:first-child tr:first-child td {
  border-top: 0; }

.table-bordered thead:first-child tr:first-child > th:first-child,
.table-bordered tbody:first-child tr:first-child > td:first-child,
.table-bordered tbody:first-child tr:first-child > th:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered thead:first-child tr:first-child > th:last-child,
.table-bordered tbody:first-child tr:first-child > td:last-child,
.table-bordered tbody:first-child tr:first-child > th:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

.table-bordered thead:last-child tr:last-child > th:first-child,
.table-bordered tbody:last-child tr:last-child > td:first-child,
.table-bordered tbody:last-child tr:last-child > th:first-child,
.table-bordered tfoot:last-child tr:last-child > td:first-child,
.table-bordered tfoot:last-child tr:last-child > th:first-child {
  -webkit-border-bottom-left-radius: 4px;
  border-bottom-left-radius: 4px;
  -moz-border-radius-bottomleft: 4px; }

.table-bordered thead:last-child tr:last-child > th:last-child,
.table-bordered tbody:last-child tr:last-child > td:last-child,
.table-bordered tbody:last-child tr:last-child > th:last-child,
.table-bordered tfoot:last-child tr:last-child > td:last-child,
.table-bordered tfoot:last-child tr:last-child > th:last-child {
  -webkit-border-bottom-right-radius: 4px;
  border-bottom-right-radius: 4px;
  -moz-border-radius-bottomright: 4px; }

.table-bordered tfoot + tbody:last-child tr:last-child td:first-child {
  -webkit-border-bottom-left-radius: 0;
  border-bottom-left-radius: 0;
  -moz-border-radius-bottomleft: 0; }

.table-bordered tfoot + tbody:last-child tr:last-child td:last-child {
  -webkit-border-bottom-right-radius: 0;
  border-bottom-right-radius: 0;
  -moz-border-radius-bottomright: 0; }

.table-bordered caption + thead tr:first-child th:first-child,
.table-bordered caption + tbody tr:first-child td:first-child,
.table-bordered colgroup + thead tr:first-child th:first-child,
.table-bordered colgroup + tbody tr:first-child td:first-child {
  -webkit-border-top-left-radius: 4px;
  border-top-left-radius: 4px;
  -moz-border-radius-topleft: 4px; }

.table-bordered caption + thead tr:first-child th:last-child,
.table-bordered caption + tbody tr:first-child td:last-child,
.table-bordered colgroup + thead tr:first-child th:last-child,
.table-bordered colgroup + tbody tr:first-child td:last-child {
  -webkit-border-top-right-radius: 4px;
  border-top-right-radius: 4px;
  -moz-border-radius-topright: 4px; }

table.docutils th {
  background-color: #e8e8e8; }

table.docutils tr:hover {
  background-color: whitesmoke; }

.table-striped tbody > tr:nth-child(odd) > td,
.table-striped tbody > tr:nth-child(odd) > th {
  background-color: rgba(252, 248, 244, 0.75); }

.table-hover tbody tr:hover > td,
.table-hover tbody tr:hover > th {
  background-color: rgba(241, 222, 204, 0.75); }

table td[class*="span"],
table th[class*="span"],
.row-fluid table td[class*="span"],
.row-fluid table th[class*="span"] {
  display: table-cell;
  float: none;
  margin-left: 0; }

.hero-unit {
  padding: 60px;
  margin-bottom: 30px;
  font-size: 18px;
  font-weight: 200;
  line-height: 30px;
  color: inherit;
  background-color: rgba(230, 197, 164, 0.75);
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.hero-unit h1 {
  margin-bottom: 0;
  font-size: 60px;
  line-height: 1;
  letter-spacing: -1px;
  color: inherit; }

.hero-unit li {
  line-height: 30px; }

/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

a.toc-backref {
  text-decoration: none;
  color: #444444; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/
div.abstract {
  margin: 2em 5em; }

div.abstract p.topic-title {
  font-weight: bold;
  text-align: center; }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em;
  border: medium outset;
  padding: 1em; }

div.note, div.warning {
  margin: 1.5em 0px;
  border: none; }

div.note p.admonition-title,
div.warning p.admonition-title {
  display: none; }

/* Clearfix
 * http://css-tricks.com/snippets/css/clear-fix/
 */
div.note:after,
div.warning:after {
  content: "";
  display: table;
  clear: both; }

div.note p:before,
div.warning p:before {
  display: block;
  float: left;
  font-size: 4em;
  line-height: 1em;
  margin-right: 20px;
  margin-left: 0em;
  margin-top: -10px;
  content: '\0270D';
  /*handwriting*/ }

div.warning p:before {
  content: '\026A0';
  /*warning*/ }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: #b30000;
  font-weight: bold;
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/
div.dedication {
  margin: 2em 5em;
  text-align: center;
  font-style: italic; }

div.dedication p.topic-title {
  font-weight: bold;
  font-style: normal; }

div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  font-size: smaller; }

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.sidebar {
  margin: 0 0 0.5em 1em;
  border: medium outset;
  padding: 1em;
  background-color: rgba(252, 248, 244, 0.75);
  width: 40%;
  float: right;
  clear: right; }

div.sidebar p.rubric {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-size: medium; }

div.system-messages {
  margin: 5em; }

div.system-messages h1 {
  color: #b30000; }

div.system-message {
  border: medium outset;
  padding: 1em; }

div.system-message p.system-message-title {
  color: #b30000;
  font-weight: bold; }

div.topic {
  margin: 2em; }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em; }

h1.title {
  text-align: center; }

h2.subtitle {
  text-align: center; }

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

/* div.align-center * { */
/*   text-align: left } */
ol.simple, ul.simple {
  margin-bottom: 1em; }

ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.sidebar-title {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold;
  font-size: larger; }

p.sidebar-subtitle {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-style: oblique; }

span.classifier-delimiter {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif;
  font-weight: bold; }

span.interpreted {
  font-family: "Helvetica Neue", "HelveticaNeue", "Raleway", Helvetica, Arial, sans-serif; }

span.option {
  white-space: nowrap; }

span.pre {
  white-space: pre; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

table.citation {
  border-left: solid 1px #666666;
  margin-left: 1px; }

table.docinfo {
  margin: 0em;
  margin-top: 2em;
  margin-bottom: 2em;
  font-family: "Raleway", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif !important;
  color: #444444; }

table.docutils {
  margin-top: 0.5em;
  margin-bottom: 0.5em; }

table.footnote {
  border-left: solid 1px #2d2d2d;
  margin-left: 1px; }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em;
  padding-right: 0.5em;
  vertical-align: top; }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: 700;
  text-align: left;
  white-space: nowrap;
  padding-left: 0; }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100%; }

ul.auto-toc {
  list-style-type: none; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #3b3b3b; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Identifier ~ span.Identifier, dt pre > span.Operator ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

dt pre > span.Operator ~ span.Identifier, dt pre > span.Operator ~ span.Operator {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 12px;
  width: 12px;
  background-position: 0 0;
  background-size: 12px 12px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }
</style>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Module libusb</h1>
    <div class="row">
  <div class="three columns">
  <ul class="simple simple-toc" id="toc-list">
<li>
  <a class="reference reference-toplevel" href="#6" id="56">Imports</a>
  <ul class="simple simple-toc-section">
    
  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#timeval"
    title="timeval = object 
  tvSec*: clong
  tvUsec*: clong"><wbr />timeval</a></li>
  <li><a class="reference" href="#LibusbClassCode"
    title="LibusbClassCode = enum 
  perInterface = 0,           ## each interface has its own class
  audio = 1,                  ## Audio class
  comm = 2,                   ## Communications class
  hid = 3,                    ## Human Interface Device class
  physical = 5,               ## Physical
  image = 6,                  ## Image class
  printer = 7,                ## Printer class
  storage = 8,                ## Image class
  hub = 9,                    ## Hub class
  data = 10,                  ## Data class
  smartCard = 0x0000000B,     ## Smart Card
  contentSecurity = 0x0000000D, ## Content Security
  video = 0x0000000E,         ## Video
  healthcare = 0x0000000F,    ## Personal Healthcare
  device = 0x000000DC,        ## Diagnostic Device
  wireless = 0x000000E0,      ## Wireless class
  application = 0x000000FE,   ## Application class
  vendorSpec = 0x000000FF     ## Class is vendor-specific"><wbr />Libusb<wbr />Class<wbr />Code</a></li>
  <li><a class="reference" href="#LibusbDescriptorType"
    title="LibusbDescriptorType = enum 
  device = 0x00000001,        ## Device descriptor
                              ## (see `LibusbDeviceDescriptor &lt;#LibusbDeviceDescriptor&gt;`_)
  config = 0x00000002,        ## Configuration descriptor
                              ## (see `LibusbConfigDescriptor &lt;#LibusbConfigDescriptor&gt;`_)
  str = 0x00000003,           ## String descriptor
  interf = 0x00000004,        ## Interface descriptor
                              ## (see `LibusbInterfaceDescriptor &lt;#LibusbInterfaceDescriptor&gt;`_)
  endpoint = 0x00000005,      ## Endpoint descriptor
                              ## (see `LibusbEndpointDescriptor &lt;#LibusbEndpointDescriptor&gt;`_)
  bos = 0x0000000F,           ## BOS descriptor
  deviceCapability = 0x00000010, ## Device capability descriptor
  hid = 0x00000021,           ## HID descriptor
  report = 0x00000022,        ## HID report descriptor
  physical = 0x00000023,      ## Physical descriptor
  hub = 0x00000029,           ## Hub descriptor
  superspeedHub = 0x0000002A, ## SuperSpeed Hub descriptor
  sSEndpointCompanion = 0x00000030 ## SuperSpeed Endpoint Companion descriptor"><wbr />Libusb<wbr />Descriptor<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbEndpointDirection"
    title="LibusbEndpointDirection = enum 
  hostToDevice = 0x00000000,  ## In: device-to-host
  deviceToHost = 0x00000080   ## Out: host-to-device"><wbr />Libusb<wbr />Endpoint<wbr />Direction</a></li>
  <li><a class="reference" href="#LibusbTransferType"
    title="LibusbTransferType = enum 
  control = 0, isochronous = 1, ## Isochronous endpoint
  bulk = 2,                   ## Bulk endpoint
  interrupt = 3,              ## Interrupt endpoint
  bulkStream = 4              ## Stream endpoint"><wbr />Libusb<wbr />Transfer<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbStandardRequest"
    title="LibusbStandardRequest = enum 
  getStatus = 0x00000000,     ## Request status of the specific recipient
  clearFeature = 0x00000001,  ## Clear or disable a specific feature
  reserved2 = 0x00000002,     ## Reserved for future use
  setFeature = 0x00000003,    ## Set or enable a specific feature
  reserved4 = 0x00000004,     ## Reserved for future use
  setAddress = 0x00000005,    ## Set device address for all future accesses
  getDescriptor = 0x00000006, ## Get the specified descriptor
  setDescriptor = 0x00000007, ## Used to update existing descriptors or add
                              ## new descriptors
  getConfiguration = 0x00000008, ## Get the current device configuration value
  setConfiguration = 0x00000009, ## Set device configuration
  getInterface = 0x0000000A,  ## Return the selected alternate setting for the
                              ## specified interface
  setInterface = 0x0000000B,  ## Select an alternate interface for the
                              ## specified interface
  synchFrame = 0x0000000C,    ## Set then report an endpoint&#x27;s synchronization
                              ## frame
  setSel = 0x00000030,        ## Sets both the U1 and U2 Exit Latency
  isochDelay = 0x00000031 ## Delay from the time a host transmits a packet to
                          ## the time it is received by the device"><wbr />Libusb<wbr />Standard<wbr />Request</a></li>
  <li><a class="reference" href="#LibusbRequestType"
    title="LibusbRequestType = enum 
  standard = (0x00000000 shl 5), ## Standard
  class = (0x00000001 shl 5), ## Class
  vendor = (0x00000002 shl 5), ## Vendor
  reserved = (0x00000003 shl 5) ## Reserved"><wbr />Libusb<wbr />Request<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbRequestRecipient"
    title="LibusbRequestRecipient = enum 
  device = 0x00000000,        ## Device
  interf = 0x00000001,        ## Interface
  endpoint = 0x00000002,      ## Endpoint
  other = 0x00000003          ## Other recipient"><wbr />Libusb<wbr />Request<wbr />Recipient</a></li>
  <li><a class="reference" href="#LibusbIsoSyncType"
    title="LibusbIsoSyncType = enum 
  none = 0,                   ## No synchronization
  async = 1,                  ## Asynchronous
  adaptive = 2,               ## Adaptive
  sync = 3                    ## Synchronous"><wbr />Libusb<wbr />Iso<wbr />Sync<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbIsoUsageType"
    title="LibusbIsoUsageType = enum 
  data = 0,                   ## Data endpoint
  feedback = 1,               ## Feedback endpoint
  implicit = 2                ## Implicit feedback Data endpoint"><wbr />Libusb<wbr />Iso<wbr />Usage<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbDeviceDescriptor"
    title="LibusbDeviceDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes)
  descriptorType*: uint8      ## Descriptor type
                              ## (`LibusbDescriptorType.device &lt;#LibusbDescriptorType&gt;`_).
  bcdUSB*: uint16 ## USB specification release number in binary-coded
                  ## decimal. 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc.
  deviceClass*: uint8         ## USB-IF class code for the device.
                              ## See `LibusbClassCode &lt;#LibusbClassCode&gt;`_.
  deviceSubClass*: uint8      ## USB-IF subclass code for the device, qualified
                              ## by the deviceClass value.
  deviceProtocol*: uint8      ## USB-IF protocol code for the device, qualified
                              ## by the deviceClass and deviceSubClass values.
  maxPacketSize0*: uint8      ## Maximum packet size for endpoint 0
  idVendor*: uint16           ## USB-IF vendor ID
  idProduct*: uint16          ## USB-IF product ID
  bcdDevice*: uint16          ## Device release number in binary-coded decimal
  iManufacturer*: uint8       ## Index of string descriptor describing manufacturer
  iProduct*: uint8            ## Index of string descriptor describing product
  iSerialNumber*: uint8       ## Index of string descriptor containing device
                              ## serial number
  numConfigurations*: uint8   ## Number of possible configurations"><wbr />Libusb<wbr />Device<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbEndpointDescriptor"
    title="LibusbEndpointDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes).
  descriptorType*: uint8      ## Descriptor type (LIBUSB_DT_ENDPOINT).
  endpointAddress*: uint8 ## The address of the endpoint described by this
                          ## descriptor. Bits 0:3 are the endpoint number. Bits 4:6 are reserved.
                          ## Bit 7 indicates direction, see
                          ## `LibusbEndpointDirection &lt;#LibusbEndpointDirection&gt;`_.
  bmAttributes*: uint8 ## Attributes which apply to the endpoint when it is
                       ## configured using the
                       ## `configurationValue &lt;#LibusbConfigDescriptor`_.
                       ## Bits 0:1 determine the transfer type and correspond to
                       ## `LibusbTransferType &lt;#LibusbTransferType&gt;`_. Bits 2:3 are only used for
                       ## isochronous endpoints and correspond to
                       ## `LibusbIsoSyncType &lt;#LibusbIsoSyncType&gt;`_. Bits 4:5 are also only used
                       ## for isochronous endpoints and correspond to
                       ## `LibusbIsoUsageType &lt;#LibusbIsoUsageType&gt;`_. Bits 6:7 are reserved.
  maxPacketSize*: uint16      ## Maximum packet size this endpoint is capable of
                              ## sending&#x2F;receiving.
  interval*: uint8            ## Interval for polling endpoint for data transfers.
  refresh*: uint8             ## For audio devices only: the rate at which
                              ## synchronization feedback is provided.
  synchAddress*: uint8 ## For audio devices only: the address if the synch
                       ## endpoint
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## endpoint descriptors, it will store them here, should you wish to parse
                  ## them.
  extraLength*: cint          ## Length of the extra descriptors, in bytes"><wbr />Libusb<wbr />Endpoint<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbInterfaceDescriptor"
    title="LibusbInterfaceDescriptor = object 
  length*: uint8
  descriptorType*: uint8      ## Descriptor type (LIBUSB_DT_INTERFACE).
  interfaceNumber*: uint8     ## Number of this interface.
  alternateSetting*: uint8    ## Value used to select this alternate setting for
                              ## this interface
  numEndpoints*: uint8        ## Number of endpoints used by this interface
                              ## (excluding the control endpoint).
  interfaceClass*: uint8      ## USB-IF class code for this interface
                              ## (see `LibusbClassCode &lt;#LibusbClassCode&gt;`_)
  interfaceSubClass*: uint8   ## USB-IF subclass code for this interface,
                              ## qualified by the ``interfaceClass`` value.
  interfaceProtocol*: uint8   ## USB-IF protocol code for this interface,
                              ## qualified by the ``interfaceClass`` and ``interfaceSubClass`` values.
  iInterface*: uint8          ## Index of string descriptor describing this interface.
  endpoint*: ptr LibusbEndpointDescriptor ## Array of endpoint descriptors.
                                          ## This length of this array is determined by the ``numEndpoints`` field.
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## interface descriptors, it will store them here, should you wish to
                  ## parse them.
  extraLength*: cint          ## Length of the extra descriptors, in bytes."><wbr />Libusb<wbr />Interface<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbInterface"
    title="LibusbInterface = object 
  altsetting*: ptr LibusbInterfaceDescriptor ## Array of interface
                                             ## descriptors. The length of this array is determined by the
                                             ## ``numAltsetting`` field.
  numAltsetting*: cint        ## The number of alternate settings that belong to
                              ## this interface."><wbr />Libusb<wbr />Interface</a></li>
  <li><a class="reference" href="#LibusbConfigDescriptor"
    title="LibusbConfigDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes) 
  descriptorType*: uint8      ## Descriptor type (LIBUSB_DT_CONFIG).
  totalLength*: uint16        ## Total length of data returned for this
                              ## configuration.
  numInterfaces*: uint8       ## Number of interfaces supported by this
                              ## configuration.
  configurationValue*: uint8  ## Identifier value for this configuration.
  iConfiguration*: uint8      ## Index of string descriptor describing this
                              ## configuration.
  bmAttributes*: uint8        ## Configuration characteristics
  maxPower*: uint8 ## Maximum power consumption of the USB device from this
                   ## bus in this configuration when the device is fully opreation.
                   ## Expressed in units of 2 mA.
  interfaces*: ptr LibusbInterface ## Array of interfaces supported by this
                                   ## configuration. The length of this array is determined by the
                                   ## ``numInterfaces`` field.
  extra*: cstring ## Extra descriptors. If libusb encounters unknown
                  ## configuration descriptors, it will store them here, should you wish to
                  ## parse them.
  extraLength*: cint          ## Length of the extra descriptors, in bytes."><wbr />Libusb<wbr />Config<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbSsEndpointCompanionDescriptor"
    title="LibusbSsEndpointCompanionDescriptor = object 
  length*: uint8              ## Size of this descriptor.
  descriptorType*: uint8      ## Descriptor type (LIBUSB_DT_SS_ENDPOINT_COMPANION).
  maxBurst*: uint8 ## The maximum number of packets the endpoint can send or
                   ## recieve as part of a burst.
  bmAttributes*: uint8 ## In bulk EP: bits 4:0 represents the maximum number
                       ## of streams the EP supports. In isochronous EP: bits 1:0 represents the
                       ## Mult - a zero based value that determines the maximum number of packets
                       ## within a service interval.
  bytesPerInterval*: uint16   ## The total number of bytes this EP will
                              ## transfer every service interval. valid only for periodic EPs."><wbr />Libusb<wbr />Ss<wbr />Endpoint<wbr />Companion<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbBosDevCapabilityDescriptor"
    title="LibusbBosDevCapabilityDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes) 
  descriptorType*: uint8      ## Descriptor type
                              ## (`LibusbDescriptorType.device &lt;#LibusbDescriptorType&gt;`_).
  devCapabilityType*: uint8   ## Device Capability type.
  devCapabilityData*: array[0, uint8] ## Device Capability data
                                      ## (`length` - 3 bytes)."><wbr />Libusb<wbr />Bos<wbr />Dev<wbr />Capability<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbBosDescriptor"
    title="LibusbBosDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes) 
  descriptorType*: uint8      ## Descriptor type (LIBUSB_DT_BOS).
  totalLength*: uint16        ## Length of this descriptor and all of its sub
                              ## descriptors.
  numDeviceCaps*: uint8       ## The number of separate device capability
                              ## descriptors in the BOS.
  devCapability*: array[0, ptr LibusbBosDevCapabilityDescriptor] ## \
                                                                 ## `bNumDeviceCap` Device Capability Descriptors."><wbr />Libusb<wbr />Bos<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbUsb20extensionDescriptor"
    title="LibusbUsb20extensionDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes).
  descriptorType*: uint8      ## Descriptor type
                              ## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).
  devCapabilityType*: uint8   ## Capability type (LIBUSB_BT_USB_2_0_EXTENSION).
  bmAttributes*: uint32 ## Bitmap encoding of supported device level
                        ## features. A value of one in a bit location indicates a feature is
                        ## supported; a  value of zero indicates it is not supported. See
                        ## `LibusbUsb20ExtensionAttributes &lt;#LibusbUsb20ExtensionAttributes&gt;`_."><wbr />Libusb<wbr />Usb20extension<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbSsUsbDeviceCapabilityDescriptor"
    title="LibusbSsUsbDeviceCapabilityDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes).
  descriptorType*: uint8      ## Descriptor type
                              ## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).
  devCapabilityType*: uint8   ## Capability type
                              ## (LIBUSB_BT_SS_USB_DEVICE_CAPABILITY).
  bmAttributes*: uint8 ## Bitmap encoding of supported device level features.
                       ## A value of one in a bit location indicates a feature is supported; a
                       ## value of zero indicates it is not supported. See
                       ## `LibusbSsUsbDeviceCapabilityAttributes &lt;#LibusbSsUsbDeviceCapabilityAttributes&gt;`_.
  speedSupported*: uint16     ## Bitmap encoding of the speed supported by this
                              ## device when operating in SuperSpeed mode. See
                              ## `LibusbSupportedSpeed &lt;#LibusbSupportedSpeed&gt;`_.
  functionalitySupport*: uint8 ## The lowest speed at which all the
                               ## functionality supported by the device is available to the user.
                               ## For example if the device supports all its functionality when connected
                               ## at full speed and above then it sets this value to 1.
  u1DevExitLat*: uint8        ## U1 Device Exit Latency.
  u2DevExitLat*: uint16       ## U2 Device Exit Latency."><wbr />Libusb<wbr />Ss<wbr />Usb<wbr />Device<wbr />Capability<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbContainerIdDescriptor"
    title="LibusbContainerIdDescriptor = object 
  length*: uint8              ## Size of this descriptor (in bytes).
  descriptorType*: uint8      ## Descriptor type
                              ## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).
  devCapabilityType*: uint8   ## Capability type (LIBUSB_BT_CONTAINER_ID).
  reserved*: uint8            ## Reserved for future use.
  containerID*: array[16, uint8] ## 128 bit UUID."><wbr />Libusb<wbr />Container<wbr />Id<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbControlSetup"
    title="LibusbControlSetup = object 
  bmRequestType*: uint8 ## Request type. Bits 0:4 determine recipient, see
                        ## `LibusbRequestRecipient`. Bits 5:6 determine type, see
                        ## `LibusbRequestType`. Bit 7 determines data transfer direction, see
                        ## `LibusbEndpointDirection &lt;#LibusbEndpointDirection&gt;`_.
  request*: uint8 ## Request. If the type bits of `bmRequestType` are equal
                  ## to `LIBUSB_REQUEST_TYPE_STANDARD` then this field refers to
                  ## `LibusbStandardRequest`. For other cases, use of this field is
                  ## application-specific.
  value*: uint16              ## Value. Varies according to request.
  index*: uint16 ## Index. Varies according to request, typically used to
                 ## pass an index or offset
  length*: uint16             ## Number of bytes to transfer."><wbr />Libusb<wbr />Control<wbr />Setup</a></li>
  <li><a class="reference" href="#LibusbVersion"
    title="LibusbVersion = object 
  major*: uint16              ## Library major version.
  minor*: uint16              ## Library minor version.
  micro*: uint16              ## Library micro version.
  nano*: uint16               ## Library nano version.
  rc*: cstring                ## Library release candidate suffix string, e.g. &quot;-rc4&quot;.
  describe*: cstring          ## For ABI compatibility only."><wbr />Libusb<wbr />Version</a></li>
  <li><a class="reference" href="#LibusbContext"
    title="LibusbContext = object"><wbr />Libusb<wbr />Context</a></li>
  <li><a class="reference" href="#LibusbDevice"
    title="LibusbDevice = object"><wbr />Libusb<wbr />Device</a></li>
  <li><a class="reference" href="#LibusbDeviceArray"
    title="LibusbDeviceArray = array[10000, ptr LibusbDevice]"><wbr />Libusb<wbr />Device<wbr />Array</a></li>
  <li><a class="reference" href="#LibusbDeviceHandle"
    title="LibusbDeviceHandle = object"><wbr />Libusb<wbr />Device<wbr />Handle</a></li>
  <li><a class="reference" href="#LibusbSpeed"
    title="LibusbSpeed = enum 
  unknown = 0,                ## The OS doesn&#x27;t report or know the device speed.
  lowSpeed = 1,               ## The device is operating at low speed (1.5MBit&#x2F;s).
  fullSpeed = 2,              ## The device is operating at full speed (12MBit&#x2F;s).
  highSpeed = 3,              ## The device is operating at high speed (480MBit&#x2F;s).
  superSpeed = 4              ##The device is operating at super speed (5000MBit&#x2F;s)."><wbr />Libusb<wbr />Speed</a></li>
  <li><a class="reference" href="#LibusbSupportedSpeed"
    title="LibusbSupportedSpeed = enum 
  lowSpeed = 1,               ## Low speed operation supported (1.5MBit&#x2F;s).
  fullSpeed = 2,              ## Full speed operation supported (12MBit&#x2F;s).
  highSpeed = 4,              ## High speed operation supported (480MBit&#x2F;s).
  superSpeed = 8              ## Superspeed operation supported (5000MBit&#x2F;s)."><wbr />Libusb<wbr />Supported<wbr />Speed</a></li>
  <li><a class="reference" href="#LibusbUsb20ExtensionAttributes"
    title="LibusbUsb20ExtensionAttributes = enum 
  linkPowerMngmt = 2          ## Supports Link Power Management (LPM)."><wbr />Libusb<wbr />Usb20Extension<wbr />Attributes</a></li>
  <li><a class="reference" href="#LibusbSsUsbDeviceCapabilityAttributes"
    title="LibusbSsUsbDeviceCapabilityAttributes = enum 
  latencyToleranceMsg = 2     ## Supports Latency Tolerance Messages (LTM)."><wbr />Libusb<wbr />Ss<wbr />Usb<wbr />Device<wbr />Capability<wbr />Attributes</a></li>
  <li><a class="reference" href="#LibusbBosType"
    title="LibusbBosType = enum 
  wirelessUsbDeviceCapability = 1, ## Wireless USB device capability.
  usb20Extension = 2,         ## USB 2.0 extensions.
  ssUsbDeviceCapability = 3,  ## SuperSpeed USB device capability.
  containerId = 4             ## Container ID type."><wbr />Libusb<wbr />Bos<wbr />Type</a></li>
  <li><a class="reference" href="#LibusbError"
    title="LibusbError = enum 
  other = - 99,               ## Other error.
  notSupported = - 12, ## Operation not supported or unimplemented on this \
                       ## platform.
  noMemory = - 11,            ## Insufficient memory.
  interrupted = - 10,         ## System call interrupted (perhaps due to signal) 
  pipe = - 9,                 ## Pipe error.
  overflow = - 8,             ## Overflow.
  timeout = - 7,              ## Operation timed out.
  busy = - 6,                 ## Resource busy.
  notFound = - 5,             ## Entity not found.
  noDevice = - 4,             ## No such device (it may have been disconnected).
  access = - 3,               ## Access denied (insufficient permissions)
  invalidParam = - 2,         ## Invalid parameter.
  io = - 1,                   ## Input&#x2F;output error.
  success = 0                 ## Success (no error)."><wbr />Libusb<wbr />Error</a></li>
  <li><a class="reference" href="#LibusbTransferStatus"
    title="LibusbTransferStatus = enum 
  completed, ## Transfer completed without error. Note that this does not
             ## indicate that the entire amount of requested data was transferred.
  error,                      ## Transfer failed.
  timedOut,                   ## Transfer timed out.
  cancelled,                  ## Transfer was cancelled.
  stall, ## For bulk&#x2F;interrupt endpoints: halt condition detected
         ## (endpoint stalled). For control endpoints: control request not
         ## supported.
  noDevice,                   ## Device was disconnected.
  overflow                    ## Device sent more data than requested."><wbr />Libusb<wbr />Transfer<wbr />Status</a></li>
  <li><a class="reference" href="#LibusbTransferFlags"
    title="LibusbTransferFlags = enum 
  shortNotOk = 1 shl 0,       ## Report short frames as errors.
  freeBuffer = 1 shl 1,       ## Automatically `free()` transfer
                              ## buffer during `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_
  freeTransfer = 1 shl 2, ## Automatically call
                          ## `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_ after callback returns.
                          ## If this flag is set, it is illegal to call
                          ## `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_ from your transfer
                          ## callback, as this will result in a double-free when this flag is acted
                          ## upon.
  addZeroPacket = 1 shl 3 ## Terminate transfers that are a multiple of the
                          ## endpoint&#x27;s `maxPacketSize &lt;#LibusbEndpointDescriptor&gt;`_ with an extra
                          ## zero length packet. This is useful when a device protocol mandates that
                          ## each logical request is terminated by an incomplete packet (i.e. the
                          ## logical requests are not separated by other means).
                          ##
                          ## This flag only affects host-to-device transfers to bulk and interrupt
                          ## endpoints. In other situations, it is ignored.
                          ##
                          ## This flag only affects transfers with a length that is a multiple of 
                          ## the endpoint&#x27;s `maxPacketSize &lt;#LibusbEndpointDescriptor&gt;`_. On
                          ## transfers of other lengths, this flag has no effect. Therefore, if you
                          ## are working with a device that needs a ZLP whenever the end of the
                          ## logical request falls on a packet boundary, then it is sensible to set
                          ## this flag on every transfer (you do not have to worry about only
                          ## setting it on transfers that end on the boundary).
                          ##
                          ## This flag is currently only supported on Linux. On other systems,
                          ## `libusbSubmitTransfer &lt;#libusbSubmitTransfer&gt;`_ will return
                          ## `LibusbError.notSupported &lt;#LibusbError&gt;`_ for every transfer where this flag is set."><wbr />Libusb<wbr />Transfer<wbr />Flags</a></li>
  <li><a class="reference" href="#LibusbIsoPacketDescriptor"
    title="LibusbIsoPacketDescriptor = object 
  length*: cuint              ## Length of data to request in this packet.
  actualLength*: cuint        ## Amount of data that was actually transferred.
  status*: LibusbTransferStatus ## Status code for this packet."><wbr />Libusb<wbr />Iso<wbr />Packet<wbr />Descriptor</a></li>
  <li><a class="reference" href="#LibusbTransferCbFn"
    title="LibusbTransferCbFn = proc (transfer: ptr LibusbTransfer)"><wbr />Libusb<wbr />Transfer<wbr />Cb<wbr />Fn</a></li>
  <li><a class="reference" href="#LibusbTransfer"
    title="LibusbTransfer = object 
  devHandle*: ptr LibusbDeviceHandle ## Handle of the device that this
                                     ## transfer will be submitted to.
  flags*: uint8               ## A bitwise OR combination of
                              ## `LibusbTransferFlags &lt;#LibusbTransferFlags&gt;`_.
  endpoint*: cuchar           ## Address of the endpoint where this transfer will be sent.
  transferType*: LibusbTransferType ## Type of the endpoint from
                                    ## `LibusbTransferType &lt;#LibusbTransferType&gt;`_.
  timeout*: cuint ## Timeout for this transfer in millseconds. A value of 0
                  ## indicates no timeout.
  status*: LibusbTransferStatus ## The status of the transfer. Read-only,
                                ## and only for use within transfer callback function.
                                ##
                                ## If this is an isochronous transfer, this field may read COMPLETED even
                                ## if there were errors in the frames. Use the
                                ## `LibusbIsoPacketDescriptor.status` field in each packet to determine
                                ## if errors occurred.
  length*: cint               ## Length of the data buffer.
  actualLength*: cint ## Actual length of data that was transferred.
                      ## Read-only, and only for use within transfer callback function.
                      ## Not valid for isochronous endpoint transfers.
  callback*: LibusbTransferCbFn ## Callback function. This will be invoked
                                ## when the transfer completes, fails, or is cancelled.
                                ## TODO: convert this to Nim
  userData*: pointer          ## User context data to pass to the callback function.
  buffer*: cstring            ## Data buffer.
  numIsoPackets*: cint ## Number of isochronous packets. Only used for I&#x2F;O
                       ## with isochronous endpoints.
  isoPacketDesc*: LibusbIsoPacketDescriptorArray ## Isochronous packet
                                                 ## descriptors, for isochronous transfers only."><wbr />Libusb<wbr />Transfer</a></li>
  <li><a class="reference" href="#LibusbCapability"
    title="LibusbCapability = enum 
  hasCapability = 0x00000000, ## The libusbHasCapability() API
                              ## is available.
  hasHotplug = 0x00000001,    ## Hotplug support is available on this
                              ## platform.
  hasHidAccess = 0x00000100, ## The library can access HID
                             ## devices without requiring user intervention. Note that before being
                             ## able to actually access an HID device, you may still have to call
                             ## additional libusb functions such as
                             ## `libusbDetachKernelDriver &lt;#libusbDetachKernelDriver&gt;`_.
  supportsDetachKernelDriver = 0x00000101 ## The library
                                          ## supports detaching of the default USB driver, using
                                          ## `libusbDetachKernelDriver &lt;#libusbDetachKernelDriver&gt;`_, if one is set
                                          ## by the OS kernel."><wbr />Libusb<wbr />Capability</a></li>
  <li><a class="reference" href="#LibusbLogLevel"
    title="LibusbLogLevel = enum 
  none = 0,                   ## No messages ever printed by the library (default)
  error,                      ## Error messages are printed to stderr
  warning,                    ## Warning and error messages are printed to stderr
  info, ## Informational messages are printed to stdout, warning and error
        ## messages are printed to stderr
  debug ## Debug and informational messages are printed to stdout, warnings
        ## and errors to stderr"><wbr />Libusb<wbr />Log<wbr />Level</a></li>
  <li><a class="reference" href="#LibusbPollfd"
    title="LibusbPollfd = object 
  fd*: cint                   ## Numeric file descriptor 
  events*: cshort ## Event flags to poll for from &lt;poll.h&gt;. POLLIN indicates
                  ## that you should monitor this file descriptor for becoming ready to read
                  ## from, and POLLOUT indicates that you should monitor this file
                  ## descriptor for nonblocking write readiness."><wbr />Libusb<wbr />Pollfd</a></li>
  <li><a class="reference" href="#LibusbPollfdAddedCb"
    title="LibusbPollfdAddedCb = proc (fd: cint; events: cshort; userData: pointer)"><wbr />Libusb<wbr />Pollfd<wbr />Added<wbr />Cb</a></li>
  <li><a class="reference" href="#LibusbPollfdRemovedCb"
    title="LibusbPollfdRemovedCb = proc (fd: cint; userData: pointer)"><wbr />Libusb<wbr />Pollfd<wbr />Removed<wbr />Cb</a></li>
  <li><a class="reference" href="#LibusbHotplugCallbackHandle"
    title="LibusbHotplugCallbackHandle = cint"><wbr />Libusb<wbr />Hotplug<wbr />Callback<wbr />Handle</a></li>
  <li><a class="reference" href="#LibusbHotplugFlag"
    title="LibusbHotplugFlag = enum 
  noFlags = 0,                ## Default value when not using any flags.
  enumerate = 1 shl 0         ## Arm the callback and fire it for all
                              ## matching currently attached devices."><wbr />Libusb<wbr />Hotplug<wbr />Flag</a></li>
  <li><a class="reference" href="#LibusbHotplugEvent"
    title="LibusbHotplugEvent = enum 
  deviceArrived = 0x00000001, ## A device has been plugged in and is ready to
                              ## use.
  deviceLeft = 0x00000002 ## A device has left and is no longer available. It
                          ## is the user&#x27;s responsibility to call `libusbClose &lt;#libusbClose&gt;`_ on
                          ## any handle associated with a disconnected device. It is safe to call
                          ## `libusbGetDeviceDescriptor &lt;#libusbGetDeviceDescriptor&gt;`_ on a device
                          ## that has left."><wbr />Libusb<wbr />Hotplug<wbr />Event</a></li>
  <li><a class="reference" href="#LibusbHotplugCallbackFn"
    title="LibusbHotplugCallbackFn = proc (ctx: ptr LibusbContext; 
                                device: ptr LibusbDevice; 
                                event: LibusbHotplugEvent; userData: pointer): cint"><wbr />Libusb<wbr />Hotplug<wbr />Callback<wbr />Fn</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libusbApiVersion"
    title="libusbApiVersion = 0x01000103"><wbr />libusb<wbr />Api<wbr />Version</a></li>
  <li><a class="reference" href="#libusbDtDeviceSize"
    title="libusbDtDeviceSize = 18"><wbr />libusb<wbr />Dt<wbr />Device<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtConfigSize"
    title="libusbDtConfigSize = 9"><wbr />libusb<wbr />Dt<wbr />Config<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtInterfaceSize"
    title="libusbDtInterfaceSize = 9"><wbr />libusb<wbr />Dt<wbr />Interface<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtEndpointSize"
    title="libusbDtEndpointSize = 7"><wbr />libusb<wbr />Dt<wbr />Endpoint<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtEndpointAudioSize"
    title="libusbDtEndpointAudioSize = 9"><wbr />libusb<wbr />Dt<wbr />Endpoint<wbr />Audio<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtHubNonvarSize"
    title="libusbDtHubNonvarSize = 7"><wbr />libusb<wbr />Dt<wbr />Hub<wbr />Nonvar<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtSsEndpointCompanionSize"
    title="libusbDtSsEndpointCompanionSize = 6"><wbr />libusb<wbr />Dt<wbr />Ss<wbr />Endpoint<wbr />Companion<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtBosSize"
    title="libusbDtBosSize = 5"><wbr />libusb<wbr />Dt<wbr />Bos<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtDeviceCapabilitySize"
    title="libusbDtDeviceCapabilitySize = 3"><wbr />libusb<wbr />Dt<wbr />Device<wbr />Capability<wbr />Size</a></li>
  <li><a class="reference" href="#libusbBtUsb20ExtensionSize"
    title="libusbBtUsb20ExtensionSize = 7"><wbr />libusb<wbr />Bt<wbr />Usb20Extension<wbr />Size</a></li>
  <li><a class="reference" href="#libusbBtSsUsbDeviceCapabilitySize"
    title="libusbBtSsUsbDeviceCapabilitySize = 10"><wbr />libusb<wbr />Bt<wbr />Ss<wbr />Usb<wbr />Device<wbr />Capability<wbr />Size</a></li>
  <li><a class="reference" href="#libusbBtContainerIdSize"
    title="libusbBtContainerIdSize = 20"><wbr />libusb<wbr />Bt<wbr />Container<wbr />Id<wbr />Size</a></li>
  <li><a class="reference" href="#libusbDtBosMaxSize"
    title="libusbDtBosMaxSize = 42"><wbr />libusb<wbr />Dt<wbr />Bos<wbr />Max<wbr />Size</a></li>
  <li><a class="reference" href="#libusbEndpointAddressMask"
    title="libusbEndpointAddressMask = 0x0000000F"><wbr />libusb<wbr />Endpoint<wbr />Address<wbr />Mask</a></li>
  <li><a class="reference" href="#libusbEndpointDirMask"
    title="libusbEndpointDirMask = 0x00000080"><wbr />libusb<wbr />Endpoint<wbr />Dir<wbr />Mask</a></li>
  <li><a class="reference" href="#libusbTransferTypeMask"
    title="libusbTransferTypeMask = 0x00000003"><wbr />libusb<wbr />Transfer<wbr />Type<wbr />Mask</a></li>
  <li><a class="reference" href="#libusbIsoSyncTypeMask"
    title="libusbIsoSyncTypeMask = 0x0000000C"><wbr />libusb<wbr />Iso<wbr />Sync<wbr />Type<wbr />Mask</a></li>
  <li><a class="reference" href="#libusbIsoUsageTypeMask"
    title="libusbIsoUsageTypeMask = 0x00000030"><wbr />libusb<wbr />Iso<wbr />Usage<wbr />Type<wbr />Mask</a></li>
  <li><a class="reference" href="#libusbErrorCount"
    title="libusbErrorCount = 14"><wbr />libusb<wbr />Error<wbr />Count</a></li>
  <li><a class="reference" href="#libusbHotplugMatchAny"
    title="libusbHotplugMatchAny = -1"><wbr />libusb<wbr />Hotplug<wbr />Match<wbr />Any</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libusbCpuToLe16,uint16"
    title="libusbCpuToLe16(x: uint16): uint16"><wbr />libusb<wbr />Cpu<wbr />To<wbr />Le16</a></li>
  <li><a class="reference" href="#libusbInit,ptr.ptr.LibusbContext"
    title="libusbInit(ctx: ptr ptr LibusbContext): cint"><wbr />libusb<wbr />Init</a></li>
  <li><a class="reference" href="#libusbExit,ptr.LibusbContext"
    title="libusbExit(ctx: ptr LibusbContext)"><wbr />libusb<wbr />Exit</a></li>
  <li><a class="reference" href="#libusbSetDebug,ptr.LibusbContext,cint"
    title="libusbSetDebug(ctx: ptr LibusbContext; level: cint)"><wbr />libusb<wbr />Set<wbr />Debug</a></li>
  <li><a class="reference" href="#libusbGetVersion,"
    title="libusbGetVersion(): ptr LibusbVersion"><wbr />libusb<wbr />Get<wbr />Version</a></li>
  <li><a class="reference" href="#libusbHasCapability,uint32"
    title="libusbHasCapability(capability: uint32): cint"><wbr />libusb<wbr />Has<wbr />Capability</a></li>
  <li><a class="reference" href="#libusbErrorName,cint"
    title="libusbErrorName(errcode: cint): cstring"><wbr />libusb<wbr />Error<wbr />Name</a></li>
  <li><a class="reference" href="#libusbSetLocale,cstring"
    title="libusbSetLocale(locale: cstring): cint"><wbr />libusb<wbr />Set<wbr />Locale</a></li>
  <li><a class="reference" href="#libusbStrError,LibusbError"
    title="libusbStrError(errcode: LibusbError): cstring"><wbr />libusb<wbr />Str<wbr />Error</a></li>
  <li><a class="reference" href="#libusbGetDeviceList,ptr.LibusbContext,ptr.ptr.LibusbDeviceArray"
    title="libusbGetDeviceList(ctx: ptr LibusbContext; list: ptr ptr LibusbDeviceArray): csize"><wbr />libusb<wbr />Get<wbr />Device<wbr />List</a></li>
  <li><a class="reference" href="#libusbFreeDeviceList,ptr.LibusbDeviceArray,cint"
    title="libusbFreeDeviceList(list: ptr LibusbDeviceArray; unrefDevices: cint)"><wbr />libusb<wbr />Free<wbr />Device<wbr />List</a></li>
  <li><a class="reference" href="#libusbRefDevice,ptr.LibusbDevice"
    title="libusbRefDevice(dev: ptr LibusbDevice): ptr LibusbDevice"><wbr />libusb<wbr />Ref<wbr />Device</a></li>
  <li><a class="reference" href="#libusbUnrefDevice,ptr.LibusbDevice"
    title="libusbUnrefDevice(dev: ptr LibusbDevice)"><wbr />libusb<wbr />Unref<wbr />Device</a></li>
  <li><a class="reference" href="#libusbGetConfiguration,ptr.LibusbDeviceHandle,ptr.cint"
    title="libusbGetConfiguration(dev: ptr LibusbDeviceHandle; config: ptr cint): cint"><wbr />libusb<wbr />Get<wbr />Configuration</a></li>
  <li><a class="reference" href="#libusbGetDeviceDescriptor,ptr.LibusbDevice,ptr.LibusbDeviceDescriptor"
    title="libusbGetDeviceDescriptor(dev: ptr LibusbDevice; 
                          desc: ptr LibusbDeviceDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Device<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetActiveConfigDescriptor,ptr.LibusbDevice,ptr.ptr.LibusbConfigDescriptor"
    title="libusbGetActiveConfigDescriptor(dev: ptr LibusbDevice; 
                                config: ptr ptr LibusbConfigDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Active<wbr />Config<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetConfigDescriptor,ptr.LibusbDevice,uint8,ptr.ptr.LibusbConfigDescriptor"
    title="libusbGetConfigDescriptor(dev: ptr LibusbDevice; config_index: uint8; 
                          config: ptr ptr LibusbConfigDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Config<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetConfigDescriptorByValue,ptr.LibusbDevice,uint8,ptr.ptr.LibusbConfigDescriptor"
    title="libusbGetConfigDescriptorByValue(dev: ptr LibusbDevice; 
                                 configurationValue: uint8; 
                                 config: ptr ptr LibusbConfigDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Config<wbr />Descriptor<wbr />By<wbr />Value</a></li>
  <li><a class="reference" href="#libusbFreeConfigDescriptor,ptr.LibusbConfigDescriptor"
    title="libusbFreeConfigDescriptor(config: ptr LibusbConfigDescriptor)"><wbr />libusb<wbr />Free<wbr />Config<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetSsEndpointCompanionDescriptor,ptr.LibusbContext,ptr.LibusbEndpointDescriptor,ptr.ptr.LibusbSsEndpointCompanionDescriptor"
    title="libusbGetSsEndpointCompanionDescriptor(ctx: ptr LibusbContext; 
                                       endpoint: ptr LibusbEndpointDescriptor; 
    ep_comp: ptr ptr LibusbSsEndpointCompanionDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Ss<wbr />Endpoint<wbr />Companion<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbFreeSsEndpointCompanionDescriptor,ptr.LibusbSsEndpointCompanionDescriptor"
    title="libusbFreeSsEndpointCompanionDescriptor(ep_comp: ptr LibusbSsEndpointCompanionDescriptor)"><wbr />libusb<wbr />Free<wbr />Ss<wbr />Endpoint<wbr />Companion<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetBosDescriptor,ptr.LibusbDeviceHandle,ptr.ptr.LibusbBosDescriptor"
    title="libusbGetBosDescriptor(handle: ptr LibusbDeviceHandle; 
                       bos: ptr ptr LibusbBosDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Bos<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbFreeBosDescriptor,ptr.LibusbBosDescriptor"
    title="libusbFreeBosDescriptor(bos: ptr LibusbBosDescriptor)"><wbr />libusb<wbr />Free<wbr />Bos<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetUsb20ExtensionDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbUsb20extensionDescriptor"
    title="libusbGetUsb20ExtensionDescriptor(ctx: ptr LibusbContext; 
                                  devCap: ptr LibusbBosDevCapabilityDescriptor; 
    usb20Extension: ptr ptr LibusbUsb20extensionDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Usb20Extension<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbFreeUsb20ExtensionDescriptor,ptr.LibusbUsb20extensionDescriptor"
    title="libusbFreeUsb20ExtensionDescriptor(usb20Extension: ptr LibusbUsb20extensionDescriptor)"><wbr />libusb<wbr />Free<wbr />Usb20Extension<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetSsUsbDeviceCapabilityDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbSsUsbDeviceCapabilityDescriptor"
    title="libusbGetSsUsbDeviceCapabilityDescriptor(ctx: ptr LibusbContext; 
    devCap: ptr LibusbBosDevCapabilityDescriptor; 
    ssUsbDeviceCap: ptr ptr LibusbSsUsbDeviceCapabilityDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Ss<wbr />Usb<wbr />Device<wbr />Capability<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbFreeSsUsbDeviceCapabilityDescriptor,ptr.LibusbSsUsbDeviceCapabilityDescriptor"
    title="libusbFreeSsUsbDeviceCapabilityDescriptor(
    ssUsbDeviceCap: ptr LibusbSsUsbDeviceCapabilityDescriptor)"><wbr />libusb<wbr />Free<wbr />Ss<wbr />Usb<wbr />Device<wbr />Capability<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetContainerIdDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbContainerIdDescriptor"
    title="libusbGetContainerIdDescriptor(ctx: ptr LibusbContext; 
                               devCap: ptr LibusbBosDevCapabilityDescriptor; 
    container_id: ptr ptr LibusbContainerIdDescriptor): cint"><wbr />libusb<wbr />Get<wbr />Container<wbr />Id<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbFreeContainerIdDescriptor,ptr.LibusbContainerIdDescriptor"
    title="libusbFreeContainerIdDescriptor(container_id: ptr LibusbContainerIdDescriptor)"><wbr />libusb<wbr />Free<wbr />Container<wbr />Id<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetBusNumber,ptr.LibusbDevice"
    title="libusbGetBusNumber(dev: ptr LibusbDevice): uint8"><wbr />libusb<wbr />Get<wbr />Bus<wbr />Number</a></li>
  <li><a class="reference" href="#libusbGetPortNumber,ptr.LibusbDevice"
    title="libusbGetPortNumber(dev: ptr LibusbDevice): uint8"><wbr />libusb<wbr />Get<wbr />Port<wbr />Number</a></li>
  <li><a class="reference" href="#libusbGetPortNumbers,ptr.LibusbDevice,ptr.uint8,cint"
    title="libusbGetPortNumbers(dev: ptr LibusbDevice; port_numbers: ptr uint8; 
                     port_numbers_len: cint): cint"><wbr />libusb<wbr />Get<wbr />Port<wbr />Numbers</a></li>
  <li><a class="reference" href="#libusbGetParent,ptr.LibusbDevice"
    title="libusbGetParent(dev: ptr LibusbDevice): ptr LibusbDevice"><wbr />libusb<wbr />Get<wbr />Parent</a></li>
  <li><a class="reference" href="#libusbGetDeviceAddress,ptr.LibusbDevice"
    title="libusbGetDeviceAddress(dev: ptr LibusbDevice): uint8"><wbr />libusb<wbr />Get<wbr />Device<wbr />Address</a></li>
  <li><a class="reference" href="#libusbGetDeviceSpeed,ptr.LibusbDevice"
    title="libusbGetDeviceSpeed(dev: ptr LibusbDevice): cint"><wbr />libusb<wbr />Get<wbr />Device<wbr />Speed</a></li>
  <li><a class="reference" href="#libusbGetMaxPacketSize,ptr.LibusbDevice,cuchar"
    title="libusbGetMaxPacketSize(dev: ptr LibusbDevice; endpoint: cuchar): cint"><wbr />libusb<wbr />Get<wbr />Max<wbr />Packet<wbr />Size</a></li>
  <li><a class="reference" href="#libusbGetMaxIsoPacketSize,ptr.LibusbDevice,cuchar"
    title="libusbGetMaxIsoPacketSize(dev: ptr LibusbDevice; endpoint: cuchar): cint"><wbr />libusb<wbr />Get<wbr />Max<wbr />Iso<wbr />Packet<wbr />Size</a></li>
  <li><a class="reference" href="#libusbOpen,ptr.LibusbDevice,ptr.ptr.LibusbDeviceHandle"
    title="libusbOpen(dev: ptr LibusbDevice; handle: ptr ptr LibusbDeviceHandle): cint"><wbr />libusb<wbr />Open</a></li>
  <li><a class="reference" href="#libusbClose,ptr.LibusbDeviceHandle"
    title="libusbClose(devHandle: ptr LibusbDeviceHandle)"><wbr />libusb<wbr />Close</a></li>
  <li><a class="reference" href="#libusbGetDevice,ptr.LibusbDeviceHandle"
    title="libusbGetDevice(devHandle: ptr LibusbDeviceHandle): ptr LibusbDevice"><wbr />libusb<wbr />Get<wbr />Device</a></li>
  <li><a class="reference" href="#libusbSetConfiguration,ptr.LibusbDeviceHandle,cint"
    title="libusbSetConfiguration(dev: ptr LibusbDeviceHandle; configuration: cint): cint"><wbr />libusb<wbr />Set<wbr />Configuration</a></li>
  <li><a class="reference" href="#libusbClaimInterface,ptr.LibusbDeviceHandle,cint"
    title="libusbClaimInterface(dev: ptr LibusbDeviceHandle; interfaceNumber: cint): cint"><wbr />libusb<wbr />Claim<wbr />Interface</a></li>
  <li><a class="reference" href="#libusbReleaseInterface,ptr.LibusbDeviceHandle,cint"
    title="libusbReleaseInterface(dev: ptr LibusbDeviceHandle; interfaceNumber: cint): cint"><wbr />libusb<wbr />Release<wbr />Interface</a></li>
  <li><a class="reference" href="#libusbOpenDeviceWithVidPid,ptr.LibusbContext,uint16,uint16"
    title="libusbOpenDeviceWithVidPid(ctx: ptr LibusbContext; vendorId: uint16; 
                           product_id: uint16): ptr LibusbDeviceHandle"><wbr />libusb<wbr />Open<wbr />Device<wbr />With<wbr />Vid<wbr />Pid</a></li>
  <li><a class="reference" href="#libusbSetInterfaceAltSetting,ptr.LibusbDeviceHandle,cint,cint"
    title="libusbSetInterfaceAltSetting(dev: ptr LibusbDeviceHandle; 
                             interface_number: cint; alternate_setting: cint): cint"><wbr />libusb<wbr />Set<wbr />Interface<wbr />Alt<wbr />Setting</a></li>
  <li><a class="reference" href="#libusbClearHalt,ptr.LibusbDeviceHandle,cuchar"
    title="libusbClearHalt(dev: ptr LibusbDeviceHandle; endpoint: cuchar): cint"><wbr />libusb<wbr />Clear<wbr />Halt</a></li>
  <li><a class="reference" href="#libusbResetDevice,ptr.LibusbDeviceHandle"
    title="libusbResetDevice(dev: ptr LibusbDeviceHandle): cint"><wbr />libusb<wbr />Reset<wbr />Device</a></li>
  <li><a class="reference" href="#libusbAllocStreams,ptr.LibusbDeviceHandle,uint32,ptr.cuchar,cint"
    title="libusbAllocStreams(dev: ptr LibusbDeviceHandle; num_streams: uint32; 
                   endpoints: ptr cuchar; num_endpoints: cint): cint"><wbr />libusb<wbr />Alloc<wbr />Streams</a></li>
  <li><a class="reference" href="#libusbFreeStreams,ptr.LibusbDeviceHandle,ptr.cuchar,cint"
    title="libusbFreeStreams(dev: ptr LibusbDeviceHandle; endpoints: ptr cuchar; 
                  num_endpoints: cint): cint"><wbr />libusb<wbr />Free<wbr />Streams</a></li>
  <li><a class="reference" href="#libusbKernelDriverActive,ptr.LibusbDeviceHandle,cint"
    title="libusbKernelDriverActive(dev: ptr LibusbDeviceHandle; interface_number: cint): cint"><wbr />libusb<wbr />Kernel<wbr />Driver<wbr />Active</a></li>
  <li><a class="reference" href="#libusbDetachKernelDriver,ptr.LibusbDeviceHandle,cint"
    title="libusbDetachKernelDriver(dev: ptr LibusbDeviceHandle; interface_number: cint): cint"><wbr />libusb<wbr />Detach<wbr />Kernel<wbr />Driver</a></li>
  <li><a class="reference" href="#libusbAttachIKernelDriver,ptr.LibusbDeviceHandle,cint"
    title="libusbAttachIKernelDriver(dev: ptr LibusbDeviceHandle; interface_number: cint): cint"><wbr />libusb<wbr />Attach<wbr />IKernel<wbr />Driver</a></li>
  <li><a class="reference" href="#libusbSetAutoDetachKernelDriver,ptr.LibusbDeviceHandle,cint"
    title="libusbSetAutoDetachKernelDriver(dev: ptr LibusbDeviceHandle; enable: cint): cint"><wbr />libusb<wbr />Set<wbr />Auto<wbr />Detach<wbr />Kernel<wbr />Driver</a></li>
  <li><a class="reference" href="#libusbControlTransferGetData,ptr.LibusbTransfer"
    title="libusbControlTransferGetData(transfer: ptr LibusbTransfer): ptr cuchar"><wbr />libusb<wbr />Control<wbr />Transfer<wbr />Get<wbr />Data</a></li>
  <li><a class="reference" href="#libusbControlTransferGetSetup,ptr.LibusbTransfer"
    title="libusbControlTransferGetSetup(transfer: ptr LibusbTransfer): ptr LibusbControlSetup"><wbr />libusb<wbr />Control<wbr />Transfer<wbr />Get<wbr />Setup</a></li>
  <li><a class="reference" href="#libusbFillControlSetup,ptr.cuchar,uint8,uint8,uint16,uint16,uint16"
    title="libusbFillControlSetup(buffer: ptr cuchar; bmRequestType: uint8; request: uint8; 
                       value: uint16; index: uint16; length: uint16)"><wbr />libusb<wbr />Fill<wbr />Control<wbr />Setup</a></li>
  <li><a class="reference" href="#libusbAllocTransfer,cint"
    title="libusbAllocTransfer(iso_packets: cint): ptr LibusbTransfer"><wbr />libusb<wbr />Alloc<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbSubmitTransfer,ptr.LibusbTransfer"
    title="libusbSubmitTransfer(transfer: ptr LibusbTransfer): cint"><wbr />libusb<wbr />Submit<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbCancelTransfer,ptr.LibusbTransfer"
    title="libusbCancelTransfer(transfer: ptr LibusbTransfer): cint"><wbr />libusb<wbr />Cancel<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbFreeTransfer,ptr.LibusbTransfer"
    title="libusbFreeTransfer(transfer: ptr LibusbTransfer)"><wbr />libusb<wbr />Free<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbTransferSetStreamId,ptr.LibusbTransfer,uint32"
    title="libusbTransferSetStreamId(transfer: ptr LibusbTransfer; stream_id: uint32)"><wbr />libusb<wbr />Transfer<wbr />Set<wbr />Stream<wbr />Id</a></li>
  <li><a class="reference" href="#libusbTransferGetStreamId,ptr.LibusbTransfer"
    title="libusbTransferGetStreamId(transfer: ptr LibusbTransfer): uint32"><wbr />libusb<wbr />Transfer<wbr />Get<wbr />Stream<wbr />Id</a></li>
  <li><a class="reference" href="#libusbFillControlTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,ptr.cuchar,LibusbTransferCbFn,pointer,cuint"
    title="libusbFillControlTransfer(transfer: ptr LibusbTransfer; 
                          devHandle: ptr LibusbDeviceHandle; buffer: ptr cuchar; 
                          callback: LibusbTransferCbFn; userData: pointer; 
                          timeout: cuint)"><wbr />libusb<wbr />Fill<wbr />Control<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbFillBulkTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"
    title="libusbFillBulkTransfer(transfer: ptr LibusbTransfer; 
                       devHandle: ptr LibusbDeviceHandle; endpoint: cuchar; 
                       buffer: ptr cuchar; length: cint; 
                       callback: LibusbTransferCbFn; userData: pointer; 
                       timeout: cuint)"><wbr />libusb<wbr />Fill<wbr />Bulk<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbFillBulkStreamTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,uint32,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"
    title="libusbFillBulkStreamTransfer(transfer: ptr LibusbTransfer; 
                             devHandle: ptr LibusbDeviceHandle; 
                             endpoint: cuchar; stream_id: uint32; 
                             buffer: ptr cuchar; length: cint; 
                             callback: LibusbTransferCbFn; userData: pointer; 
                             timeout: cuint)"><wbr />libusb<wbr />Fill<wbr />Bulk<wbr />Stream<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbFillInterruptTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"
    title="libusbFillInterruptTransfer(transfer: ptr LibusbTransfer; 
                            devHandle: ptr LibusbDeviceHandle; endpoint: cuchar; 
                            buffer: ptr cuchar; length: cint; 
                            callback: LibusbTransferCbFn; userData: pointer; 
                            timeout: cuint)"><wbr />libusb<wbr />Fill<wbr />Interrupt<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbFillIsoTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,cint,LibusbTransferCbFn,pointer,cuint"
    title="libusbFillIsoTransfer(transfer: ptr LibusbTransfer; 
                      devHandle: ptr LibusbDeviceHandle; endpoint: cuchar; 
                      buffer: ptr cuchar; length: cint; numIsoPackets: cint; 
                      callback: LibusbTransferCbFn; userData: pointer; 
                      timeout: cuint)"><wbr />libusb<wbr />Fill<wbr />Iso<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbSetIsoPacketLengths,ptr.LibusbTransfer,cuint"
    title="libusbSetIsoPacketLengths(transfer: ptr LibusbTransfer; length: cuint)"><wbr />libusb<wbr />Set<wbr />Iso<wbr />Packet<wbr />Lengths</a></li>
  <li><a class="reference" href="#libusbGetIsoPacketBuffer,ptr.LibusbTransfer,cuint"
    title="libusbGetIsoPacketBuffer(transfer: ptr LibusbTransfer; packet: cuint): ptr cuchar"><wbr />libusb<wbr />Get<wbr />Iso<wbr />Packet<wbr />Buffer</a></li>
  <li><a class="reference" href="#libusbGetIsoPacketBufferSimple,ptr.LibusbTransfer,cuint"
    title="libusbGetIsoPacketBufferSimple(transfer: ptr LibusbTransfer; packet: cuint): ptr cuchar"><wbr />libusb<wbr />Get<wbr />Iso<wbr />Packet<wbr />Buffer<wbr />Simple</a></li>
  <li><a class="reference" href="#libusbControlTransfer,ptr.LibusbDeviceHandle,LibusbEndpointDirection,LibusbStandardRequest,uint16,uint16,ptr.cuchar,uint16,cuint"
    title="libusbControlTransfer(devHandle: ptr LibusbDeviceHandle; 
                      request_type: LibusbEndpointDirection; 
                      request: LibusbStandardRequest; value: uint16; 
                      index: uint16; data: ptr cuchar; length: uint16; 
                      timeout: cuint): cint"><wbr />libusb<wbr />Control<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbBulkTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"
    title="libusbBulkTransfer(devHandle: ptr LibusbDeviceHandle; endpoint: cuchar; 
                   data: ptr cuchar; length: cint; actualLength: ptr cint; 
                   timeout: cuint): cint"><wbr />libusb<wbr />Bulk<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbInterruptTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"
    title="libusbInterruptTransfer(devHandle: ptr LibusbDeviceHandle; endpoint: cuchar; 
                        data: ptr cuchar; length: cint; actualLength: ptr cint; 
                        timeout: cuint): cint"><wbr />libusb<wbr />Interrupt<wbr />Transfer</a></li>
  <li><a class="reference" href="#libusbGetDescriptor,ptr.LibusbDeviceHandle,uint8,uint8,ptr.cuchar,cint"
    title="libusbGetDescriptor(dev: ptr LibusbDeviceHandle; desc_type: uint8; 
                    desc_index: uint8; data: ptr cuchar; length: cint): cint"><wbr />libusb<wbr />Get<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetStringDescriptor,ptr.LibusbDeviceHandle,uint8,uint16,ptr.cuchar,cint"
    title="libusbGetStringDescriptor(dev: ptr LibusbDeviceHandle; desc_index: uint8; 
                          langid: uint16; data: ptr cuchar; length: cint): cint"><wbr />libusb<wbr />Get<wbr />String<wbr />Descriptor</a></li>
  <li><a class="reference" href="#libusbGetStringDescriptorAscii,ptr.LibusbDeviceHandle,uint8,ptr.cuchar,cint"
    title="libusbGetStringDescriptorAscii(dev: ptr LibusbDeviceHandle; desc_index: uint8; 
                               data: ptr cuchar; length: cint): cint"><wbr />libusb<wbr />Get<wbr />String<wbr />Descriptor<wbr />Ascii</a></li>
  <li><a class="reference" href="#libusbTryLockEvents,ptr.LibusbContext"
    title="libusbTryLockEvents(ctx: ptr LibusbContext): cint"><wbr />libusb<wbr />Try<wbr />Lock<wbr />Events</a></li>
  <li><a class="reference" href="#libusbLockEvents,ptr.LibusbContext"
    title="libusbLockEvents(ctx: ptr LibusbContext)"><wbr />libusb<wbr />Lock<wbr />Events</a></li>
  <li><a class="reference" href="#libusbUnlockEvents,ptr.LibusbContext"
    title="libusbUnlockEvents(ctx: ptr LibusbContext)"><wbr />libusb<wbr />Unlock<wbr />Events</a></li>
  <li><a class="reference" href="#libusbEventHandlingOk,ptr.LibusbContext"
    title="libusbEventHandlingOk(ctx: ptr LibusbContext): cint"><wbr />libusb<wbr />Event<wbr />Handling<wbr />Ok</a></li>
  <li><a class="reference" href="#libusbEventHandlerActive,ptr.LibusbContext"
    title="libusbEventHandlerActive(ctx: ptr LibusbContext): cint"><wbr />libusb<wbr />Event<wbr />Handler<wbr />Active</a></li>
  <li><a class="reference" href="#libusbLockEventWaiters,ptr.LibusbContext"
    title="libusbLockEventWaiters(ctx: ptr LibusbContext)"><wbr />libusb<wbr />Lock<wbr />Event<wbr />Waiters</a></li>
  <li><a class="reference" href="#libusbUnlockEventWaiters,ptr.LibusbContext"
    title="libusbUnlockEventWaiters(ctx: ptr LibusbContext)"><wbr />libusb<wbr />Unlock<wbr />Event<wbr />Waiters</a></li>
  <li><a class="reference" href="#libusbWaitForEvent,ptr.LibusbContext,ptr.timeval"
    title="libusbWaitForEvent(ctx: ptr LibusbContext; tv: ptr timeval): cint"><wbr />libusb<wbr />Wait<wbr />For<wbr />Event</a></li>
  <li><a class="reference" href="#libusbHandleEvents,ptr.LibusbContext"
    title="libusbHandleEvents(ctx: ptr LibusbContext): cint"><wbr />libusb<wbr />Handle<wbr />Events</a></li>
  <li><a class="reference" href="#libusbHandleEventsTimeoutCompleted,ptr.LibusbContext,ptr.timeval,ptr.cint"
    title="libusbHandleEventsTimeoutCompleted(ctx: ptr LibusbContext; tv: ptr timeval; 
                                   completed: ptr cint): cint"><wbr />libusb<wbr />Handle<wbr />Events<wbr />Timeout<wbr />Completed</a></li>
  <li><a class="reference" href="#libusbHandleEventsCompleted,ptr.LibusbContext,ptr.cint"
    title="libusbHandleEventsCompleted(ctx: ptr LibusbContext; completed: ptr cint): cint"><wbr />libusb<wbr />Handle<wbr />Events<wbr />Completed</a></li>
  <li><a class="reference" href="#libusbHandleEventsLocked,ptr.LibusbContext,ptr.timeval"
    title="libusbHandleEventsLocked(ctx: ptr LibusbContext; tv: ptr timeval): cint"><wbr />libusb<wbr />Handle<wbr />Events<wbr />Locked</a></li>
  <li><a class="reference" href="#libusbPollfdsHandleTimeouts,ptr.LibusbContext"
    title="libusbPollfdsHandleTimeouts(ctx: ptr LibusbContext): cint"><wbr />libusb<wbr />Pollfds<wbr />Handle<wbr />Timeouts</a></li>
  <li><a class="reference" href="#libusbGetNextTimeout,ptr.LibusbContext,ptr.timeval"
    title="libusbGetNextTimeout(ctx: ptr LibusbContext; tv: ptr timeval): cint"><wbr />libusb<wbr />Get<wbr />Next<wbr />Timeout</a></li>
  <li><a class="reference" href="#libusbGetPollfds,ptr.LibusbContext"
    title="libusbGetPollfds(ctx: ptr LibusbContext): ptr ptr LibusbPollfd"><wbr />libusb<wbr />Get<wbr />Pollfds</a></li>
  <li><a class="reference" href="#libusbSetPollfdNotifiers,ptr.LibusbContext,LibusbPollfdAddedCb,LibusbPollfdRemovedCb,pointer"
    title="libusbSetPollfdNotifiers(ctx: ptr LibusbContext; added_cb: LibusbPollfdAddedCb; 
                         removed_cb: LibusbPollfdRemovedCb; userData: pointer)"><wbr />libusb<wbr />Set<wbr />Pollfd<wbr />Notifiers</a></li>
  <li><a class="reference" href="#libusbHotplugRegisterCallback,ptr.LibusbContext,LibusbHotplugEvent,LibusbHotplugFlag,cint,cint,cint,LibusbHotplugCallbackFn,pointer,ptr.LibusbHotplugCallbackHandle"
    title="libusbHotplugRegisterCallback(ctx: ptr LibusbContext; 
                              events: LibusbHotplugEvent; 
                              flags: LibusbHotplugFlag; vendor_id: cint; 
                              product_id: cint; dev_class: cint; 
                              cb_fn: LibusbHotplugCallbackFn; userData: pointer; 
                              handle: ptr LibusbHotplugCallbackHandle): cint"><wbr />libusb<wbr />Hotplug<wbr />Register<wbr />Callback</a></li>
  <li><a class="reference" href="#libusbHotplugDeregisterCallback,ptr.LibusbContext,LibusbHotplugCallbackHandle"
    title="libusbHotplugDeregisterCallback(ctx: ptr LibusbContext; 
                                handle: LibusbHotplugCallbackHandle)"><wbr />libusb<wbr />Hotplug<wbr />Deregister<wbr />Callback</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#libusbLe16ToCpu.t,uint16"
    title="libusbLe16ToCpu(x: uint16): uint16"><wbr />libusb<wbr />Le16To<wbr />Cpu</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <p class="module-desc"><p><em>io-usb</em> - Nim bindings for libusb, the cross-platform user library to access USB devices.</p>
<p>This file is part of the <a class="reference external" href="http://nimio.us">Nim I/O</a> package collection. See the file LICENSE included in this distribution for licensing details. GitHub pull requests are encouraged. (c) 2015 Headcrash Industries LLC.</p>
</p>
  <div class="section" id="6">
<h1><a class="toc-backref" href="#6">Imports</a></h1>
<dl class="item">
<a class="reference external" href="endians.html">endians</a>, <a class="reference external" href="unsigned.html">unsigned</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<dt id="timeval"><a name="timeval"></a><pre><span class="Identifier">timeval</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">tvSec</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">clong</span>
  <span class="Identifier">tvUsec</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">clong</span>
</pre></dt>
<dd>
Specifies a time interval.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L26"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbClassCode"><a name="LibusbClassCode"></a><pre><span class="Identifier">LibusbClassCode</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">perInterface</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>           <span class="Comment">## each interface has its own class</span>
  <span class="Identifier">audio</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>                  <span class="Comment">## Audio class</span>
  <span class="Identifier">comm</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>                   <span class="Comment">## Communications class</span>
  <span class="Identifier">hid</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>                    <span class="Comment">## Human Interface Device class</span>
  <span class="Identifier">physical</span> <span class="Other">=</span> <span class="DecNumber">5</span><span class="Other">,</span>               <span class="Comment">## Physical</span>
  <span class="Identifier">image</span> <span class="Other">=</span> <span class="DecNumber">6</span><span class="Other">,</span>                  <span class="Comment">## Image class</span>
  <span class="Identifier">printer</span> <span class="Other">=</span> <span class="DecNumber">7</span><span class="Other">,</span>                <span class="Comment">## Printer class</span>
  <span class="Identifier">storage</span> <span class="Other">=</span> <span class="DecNumber">8</span><span class="Other">,</span>                <span class="Comment">## Image class</span>
  <span class="Identifier">hub</span> <span class="Other">=</span> <span class="DecNumber">9</span><span class="Other">,</span>                    <span class="Comment">## Hub class</span>
  <span class="Identifier">data</span> <span class="Other">=</span> <span class="DecNumber">10</span><span class="Other">,</span>                  <span class="Comment">## Data class</span>
  <span class="Identifier">smartCard</span> <span class="Other">=</span> <span class="DecNumber">0x0000000B</span><span class="Other">,</span>     <span class="Comment">## Smart Card</span>
  <span class="Identifier">contentSecurity</span> <span class="Other">=</span> <span class="DecNumber">0x0000000D</span><span class="Other">,</span> <span class="Comment">## Content Security</span>
  <span class="Identifier">video</span> <span class="Other">=</span> <span class="DecNumber">0x0000000E</span><span class="Other">,</span>         <span class="Comment">## Video</span>
  <span class="Identifier">healthcare</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span><span class="Other">,</span>    <span class="Comment">## Personal Healthcare</span>
  <span class="Identifier">device</span> <span class="Other">=</span> <span class="DecNumber">0x000000DC</span><span class="Other">,</span>        <span class="Comment">## Diagnostic Device</span>
  <span class="Identifier">wireless</span> <span class="Other">=</span> <span class="DecNumber">0x000000E0</span><span class="Other">,</span>      <span class="Comment">## Wireless class</span>
  <span class="Identifier">application</span> <span class="Other">=</span> <span class="DecNumber">0x000000FE</span><span class="Other">,</span>   <span class="Comment">## Application class</span>
  <span class="Identifier">vendorSpec</span> <span class="Other">=</span> <span class="DecNumber">0x000000FF</span>     <span class="Comment">## Class is vendor-specific</span></pre></dt>
<dd>

Enumerates USB device class codes.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L60"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbDescriptorType"><a name="LibusbDescriptorType"></a><pre><span class="Identifier">LibusbDescriptorType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">device</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span>        <span class="Comment">## Device descriptor</span>
                              <span class="Comment">## (see `LibusbDeviceDescriptor &lt;#LibusbDeviceDescriptor&gt;`_)</span>
  <span class="Identifier">config</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span>        <span class="Comment">## Configuration descriptor</span>
                              <span class="Comment">## (see `LibusbConfigDescriptor &lt;#LibusbConfigDescriptor&gt;`_)</span>
  <span class="Identifier">str</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span><span class="Other">,</span>           <span class="Comment">## String descriptor</span>
  <span class="Identifier">interf</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span><span class="Other">,</span>        <span class="Comment">## Interface descriptor</span>
                              <span class="Comment">## (see `LibusbInterfaceDescriptor &lt;#LibusbInterfaceDescriptor&gt;`_)</span>
  <span class="Identifier">endpoint</span> <span class="Other">=</span> <span class="DecNumber">0x00000005</span><span class="Other">,</span>      <span class="Comment">## Endpoint descriptor</span>
                              <span class="Comment">## (see `LibusbEndpointDescriptor &lt;#LibusbEndpointDescriptor&gt;`_)</span>
  <span class="Identifier">bos</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span><span class="Other">,</span>           <span class="Comment">## BOS descriptor</span>
  <span class="Identifier">deviceCapability</span> <span class="Other">=</span> <span class="DecNumber">0x00000010</span><span class="Other">,</span> <span class="Comment">## Device capability descriptor</span>
  <span class="Identifier">hid</span> <span class="Other">=</span> <span class="DecNumber">0x00000021</span><span class="Other">,</span>           <span class="Comment">## HID descriptor</span>
  <span class="Identifier">report</span> <span class="Other">=</span> <span class="DecNumber">0x00000022</span><span class="Other">,</span>        <span class="Comment">## HID report descriptor</span>
  <span class="Identifier">physical</span> <span class="Other">=</span> <span class="DecNumber">0x00000023</span><span class="Other">,</span>      <span class="Comment">## Physical descriptor</span>
  <span class="Identifier">hub</span> <span class="Other">=</span> <span class="DecNumber">0x00000029</span><span class="Other">,</span>           <span class="Comment">## Hub descriptor</span>
  <span class="Identifier">superspeedHub</span> <span class="Other">=</span> <span class="DecNumber">0x0000002A</span><span class="Other">,</span> <span class="Comment">## SuperSpeed Hub descriptor</span>
  <span class="Identifier">sSEndpointCompanion</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span> <span class="Comment">## SuperSpeed Endpoint Companion descriptor</span></pre></dt>
<dd>

Enumerates device descriptor types.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L81"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbEndpointDirection"><a name="LibusbEndpointDirection"></a><pre><span class="Identifier">LibusbEndpointDirection</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">hostToDevice</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span>  <span class="Comment">## In: device-to-host</span>
  <span class="Identifier">deviceToHost</span> <span class="Other">=</span> <span class="DecNumber">0x00000080</span>   <span class="Comment">## Out: host-to-device</span></pre></dt>
<dd>

Enumerates available endpoint directions (bit 7 of the <a class="reference external" href="#LibusbEndpointDescriptor">LibusbEndpointDescriptor.endpointAddress</a> scheme)
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L131"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbTransferType"><a name="LibusbTransferType"></a><pre><span class="Identifier">LibusbTransferType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">control</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">isochronous</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Isochronous endpoint</span>
  <span class="Identifier">bulk</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>                   <span class="Comment">## Bulk endpoint</span>
  <span class="Identifier">interrupt</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>              <span class="Comment">## Interrupt endpoint</span>
  <span class="Identifier">bulkStream</span> <span class="Other">=</span> <span class="DecNumber">4</span>              <span class="Comment">## Stream endpoint</span></pre></dt>
<dd>

Enumerates endpoint transfer types.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L144"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbStandardRequest"><a name="LibusbStandardRequest"></a><pre><span class="Identifier">LibusbStandardRequest</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">getStatus</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span>     <span class="Comment">## Request status of the specific recipient</span>
  <span class="Identifier">clearFeature</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span>  <span class="Comment">## Clear or disable a specific feature</span>
  <span class="Identifier">reserved2</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span>     <span class="Comment">## Reserved for future use</span>
  <span class="Identifier">setFeature</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span><span class="Other">,</span>    <span class="Comment">## Set or enable a specific feature</span>
  <span class="Identifier">reserved4</span> <span class="Other">=</span> <span class="DecNumber">0x00000004</span><span class="Other">,</span>     <span class="Comment">## Reserved for future use</span>
  <span class="Identifier">setAddress</span> <span class="Other">=</span> <span class="DecNumber">0x00000005</span><span class="Other">,</span>    <span class="Comment">## Set device address for all future accesses</span>
  <span class="Identifier">getDescriptor</span> <span class="Other">=</span> <span class="DecNumber">0x00000006</span><span class="Other">,</span> <span class="Comment">## Get the specified descriptor</span>
  <span class="Identifier">setDescriptor</span> <span class="Other">=</span> <span class="DecNumber">0x00000007</span><span class="Other">,</span> <span class="Comment">## Used to update existing descriptors or add</span>
                              <span class="Comment">## new descriptors</span>
  <span class="Identifier">getConfiguration</span> <span class="Other">=</span> <span class="DecNumber">0x00000008</span><span class="Other">,</span> <span class="Comment">## Get the current device configuration value</span>
  <span class="Identifier">setConfiguration</span> <span class="Other">=</span> <span class="DecNumber">0x00000009</span><span class="Other">,</span> <span class="Comment">## Set device configuration</span>
  <span class="Identifier">getInterface</span> <span class="Other">=</span> <span class="DecNumber">0x0000000A</span><span class="Other">,</span>  <span class="Comment">## Return the selected alternate setting for the</span>
                              <span class="Comment">## specified interface</span>
  <span class="Identifier">setInterface</span> <span class="Other">=</span> <span class="DecNumber">0x0000000B</span><span class="Other">,</span>  <span class="Comment">## Select an alternate interface for the</span>
                              <span class="Comment">## specified interface</span>
  <span class="Identifier">synchFrame</span> <span class="Other">=</span> <span class="DecNumber">0x0000000C</span><span class="Other">,</span>    <span class="Comment">## Set then report an endpoint's synchronization</span>
                              <span class="Comment">## frame</span>
  <span class="Identifier">setSel</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span><span class="Other">,</span>        <span class="Comment">## Sets both the U1 and U2 Exit Latency</span>
  <span class="Identifier">isochDelay</span> <span class="Other">=</span> <span class="DecNumber">0x00000031</span> <span class="Comment">## Delay from the time a host transmits a packet to</span>
                          <span class="Comment">## the time it is received by the device</span></pre></dt>
<dd>

Enumerates standard requests as defined in table 9-5 of the USB 3.0 spec.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L153"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbRequestType"><a name="LibusbRequestType"></a><pre><span class="Identifier">LibusbRequestType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">standard</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000000</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Standard</span>
  <span class="Identifier">class</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000001</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Class</span>
  <span class="Identifier">vendor</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000002</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span><span class="Other">,</span> <span class="Comment">## Vendor</span>
  <span class="Identifier">reserved</span> <span class="Other">=</span> <span class="Other">(</span><span class="DecNumber">0x00000003</span> <span class="Keyword">shl</span> <span class="DecNumber">5</span><span class="Other">)</span> <span class="Comment">## Reserved</span></pre></dt>
<dd>

Enumerates standard requests, as defined in table 9-5 of the USB 3.0 spec.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L177"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbRequestRecipient"><a name="LibusbRequestRecipient"></a><pre><span class="Identifier">LibusbRequestRecipient</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">device</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span>        <span class="Comment">## Device</span>
  <span class="Identifier">interf</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span>        <span class="Comment">## Interface</span>
  <span class="Identifier">endpoint</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span><span class="Other">,</span>      <span class="Comment">## Endpoint</span>
  <span class="Identifier">other</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span>          <span class="Comment">## Other recipient</span></pre></dt>
<dd>

Enumerates recipient bits in the LibusbControlSetup.bmRequestType 
field. Values 4 through 31 are reserved.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L185"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbIsoSyncType"><a name="LibusbIsoSyncType"></a><pre><span class="Identifier">LibusbIsoSyncType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">none</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>                   <span class="Comment">## No synchronization</span>
  <span class="Identifier">async</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>                  <span class="Comment">## Asynchronous</span>
  <span class="Identifier">adaptive</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>               <span class="Comment">## Adaptive</span>
  <span class="Identifier">sync</span> <span class="Other">=</span> <span class="DecNumber">3</span>                    <span class="Comment">## Synchronous</span></pre></dt>
<dd>

Enumerates synchronization types for isochronous endpoints.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L198"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbIsoUsageType"><a name="LibusbIsoUsageType"></a><pre><span class="Identifier">LibusbIsoUsageType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">data</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>                   <span class="Comment">## Data endpoint</span>
  <span class="Identifier">feedback</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>               <span class="Comment">## Feedback endpoint</span>
  <span class="Identifier">implicit</span> <span class="Other">=</span> <span class="DecNumber">2</span>                <span class="Comment">## Implicit feedback Data endpoint</span></pre></dt>
<dd>

Enumerates usage types for isochronous endpoints.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L210"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbDeviceDescriptor"><a name="LibusbDeviceDescriptor"></a><pre><span class="Identifier">LibusbDeviceDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes)</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type</span>
                              <span class="Comment">## (`LibusbDescriptorType.device &lt;#LibusbDescriptorType&gt;`_).</span>
  <span class="Identifier">bcdUSB</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Comment">## USB specification release number in binary-coded</span>
                  <span class="Comment">## decimal. 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc.</span>
  <span class="Identifier">deviceClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>         <span class="Comment">## USB-IF class code for the device.</span>
                              <span class="Comment">## See `LibusbClassCode &lt;#LibusbClassCode&gt;`_.</span>
  <span class="Identifier">deviceSubClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## USB-IF subclass code for the device, qualified</span>
                              <span class="Comment">## by the deviceClass value.</span>
  <span class="Identifier">deviceProtocol</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## USB-IF protocol code for the device, qualified</span>
                              <span class="Comment">## by the deviceClass and deviceSubClass values.</span>
  <span class="Identifier">maxPacketSize0</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Maximum packet size for endpoint 0</span>
  <span class="Identifier">idVendor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>           <span class="Comment">## USB-IF vendor ID</span>
  <span class="Identifier">idProduct</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>          <span class="Comment">## USB-IF product ID</span>
  <span class="Identifier">bcdDevice</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>          <span class="Comment">## Device release number in binary-coded decimal</span>
  <span class="Identifier">iManufacturer</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Index of string descriptor describing manufacturer</span>
  <span class="Identifier">iProduct</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>            <span class="Comment">## Index of string descriptor describing product</span>
  <span class="Identifier">iSerialNumber</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Index of string descriptor containing device</span>
                              <span class="Comment">## serial number</span>
  <span class="Identifier">numConfigurations</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Number of possible configurations</span>
  </pre></dt>
<dd>
Standard USB device descriptor. This descriptor is documented in section 9.6.1 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L218"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbEndpointDescriptor"><a name="LibusbEndpointDescriptor"></a><pre><span class="Identifier">LibusbEndpointDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type (LIBUSB_DT_ENDPOINT).</span>
  <span class="Identifier">endpointAddress</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The address of the endpoint described by this</span>
                          <span class="Comment">## descriptor. Bits 0:3 are the endpoint number. Bits 4:6 are reserved.</span>
                          <span class="Comment">## Bit 7 indicates direction, see</span>
                          <span class="Comment">## `LibusbEndpointDirection &lt;#LibusbEndpointDirection&gt;`_.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Attributes which apply to the endpoint when it is</span>
                       <span class="Comment">## configured using the</span>
                       <span class="Comment">## `configurationValue &lt;#LibusbConfigDescriptor`_.</span>
                       <span class="Comment">## Bits 0:1 determine the transfer type and correspond to</span>
                       <span class="Comment">## `LibusbTransferType &lt;#LibusbTransferType&gt;`_. Bits 2:3 are only used for</span>
                       <span class="Comment">## isochronous endpoints and correspond to</span>
                       <span class="Comment">## `LibusbIsoSyncType &lt;#LibusbIsoSyncType&gt;`_. Bits 4:5 are also only used</span>
                       <span class="Comment">## for isochronous endpoints and correspond to</span>
                       <span class="Comment">## `LibusbIsoUsageType &lt;#LibusbIsoUsageType&gt;`_. Bits 6:7 are reserved.</span>
  <span class="Identifier">maxPacketSize</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>      <span class="Comment">## Maximum packet size this endpoint is capable of</span>
                              <span class="Comment">## sending/receiving.</span>
  <span class="Identifier">interval</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>            <span class="Comment">## Interval for polling endpoint for data transfers.</span>
  <span class="Identifier">refresh</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>             <span class="Comment">## For audio devices only: the rate at which</span>
                              <span class="Comment">## synchronization feedback is provided.</span>
  <span class="Identifier">synchAddress</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## For audio devices only: the address if the synch</span>
                       <span class="Comment">## endpoint</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## endpoint descriptors, it will store them here, should you wish to parse</span>
                  <span class="Comment">## them.</span>
  <span class="Identifier">extraLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>          <span class="Comment">## Length of the extra descriptors, in bytes</span>
  </pre></dt>
<dd>
Standard USB endpoint descriptor. This descriptor is documented in section 9.6.6 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L244"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbInterfaceDescriptor"><a name="LibusbInterfaceDescriptor"></a><pre><span class="Identifier">LibusbInterfaceDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type (LIBUSB_DT_INTERFACE).</span>
  <span class="Identifier">interfaceNumber</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>     <span class="Comment">## Number of this interface.</span>
  <span class="Identifier">alternateSetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>    <span class="Comment">## Value used to select this alternate setting for</span>
                              <span class="Comment">## this interface</span>
  <span class="Identifier">numEndpoints</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>        <span class="Comment">## Number of endpoints used by this interface</span>
                              <span class="Comment">## (excluding the control endpoint).</span>
  <span class="Identifier">interfaceClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## USB-IF class code for this interface</span>
                              <span class="Comment">## (see `LibusbClassCode &lt;#LibusbClassCode&gt;`_)</span>
  <span class="Identifier">interfaceSubClass</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## USB-IF subclass code for this interface,</span>
                              <span class="Comment">## qualified by the ``interfaceClass`` value.</span>
  <span class="Identifier">interfaceProtocol</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## USB-IF protocol code for this interface,</span>
                              <span class="Comment">## qualified by the ``interfaceClass`` and ``interfaceSubClass`` values.</span>
  <span class="Identifier">iInterface</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>          <span class="Comment">## Index of string descriptor describing this interface.</span>
  <span class="Identifier">endpoint</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbEndpointDescriptor</span> <span class="Comment">## Array of endpoint descriptors.</span>
                                          <span class="Comment">## This length of this array is determined by the ``numEndpoints`` field.</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## interface descriptors, it will store them here, should you wish to</span>
                  <span class="Comment">## parse them.</span>
  <span class="Identifier">extraLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>          <span class="Comment">## Length of the extra descriptors, in bytes.</span>
  </pre></dt>
<dd>
A structure representing the standard USB interface descriptor. This descriptor is documented in section 9.6.5 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L276"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbInterface"><a name="LibusbInterface"></a><pre><span class="Identifier">LibusbInterface</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">altsetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbInterfaceDescriptor</span> <span class="Comment">## Array of interface</span>
                                             <span class="Comment">## descriptors. The length of this array is determined by the</span>
                                             <span class="Comment">## ``numAltsetting`` field.</span>
  <span class="Identifier">numAltsetting</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>        <span class="Comment">## The number of alternate settings that belong to</span>
                              <span class="Comment">## this interface.</span>
  </pre></dt>
<dd>
Collection of alternate settings for a particular USB interface.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L302"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbConfigDescriptor"><a name="LibusbConfigDescriptor"></a><pre><span class="Identifier">LibusbConfigDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type (LIBUSB_DT_CONFIG).</span>
  <span class="Identifier">totalLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>        <span class="Comment">## Total length of data returned for this</span>
                              <span class="Comment">## configuration.</span>
  <span class="Identifier">numInterfaces</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## Number of interfaces supported by this</span>
                              <span class="Comment">## configuration.</span>
  <span class="Identifier">configurationValue</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>  <span class="Comment">## Identifier value for this configuration.</span>
  <span class="Identifier">iConfiguration</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Index of string descriptor describing this</span>
                              <span class="Comment">## configuration.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>        <span class="Comment">## Configuration characteristics</span>
  <span class="Identifier">maxPower</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Maximum power consumption of the USB device from this</span>
                   <span class="Comment">## bus in this configuration when the device is fully opreation.</span>
                   <span class="Comment">## Expressed in units of 2 mA.</span>
  <span class="Identifier">interfaces</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbInterface</span> <span class="Comment">## Array of interfaces supported by this</span>
                                   <span class="Comment">## configuration. The length of this array is determined by the</span>
                                   <span class="Comment">## ``numInterfaces`` field.</span>
  <span class="Identifier">extra</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Comment">## Extra descriptors. If libusb encounters unknown</span>
                  <span class="Comment">## configuration descriptors, it will store them here, should you wish to</span>
                  <span class="Comment">## parse them.</span>
  <span class="Identifier">extraLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>          <span class="Comment">## Length of the extra descriptors, in bytes.</span>
  </pre></dt>
<dd>
A structure representing the standard USB configuration descriptor. This descriptor is documented in section 9.6.3 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L311"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbSsEndpointCompanionDescriptor"><a name="LibusbSsEndpointCompanionDescriptor"></a><pre><span class="Identifier">LibusbSsEndpointCompanionDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor.</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type (LIBUSB_DT_SS_ENDPOINT_COMPANION).</span>
  <span class="Identifier">maxBurst</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The maximum number of packets the endpoint can send or</span>
                   <span class="Comment">## recieve as part of a burst.</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## In bulk EP: bits 4:0 represents the maximum number</span>
                       <span class="Comment">## of streams the EP supports. In isochronous EP: bits 1:0 represents the</span>
                       <span class="Comment">## Mult - a zero based value that determines the maximum number of packets</span>
                       <span class="Comment">## within a service interval.</span>
  <span class="Identifier">bytesPerInterval</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>   <span class="Comment">## The total number of bytes this EP will</span>
                              <span class="Comment">## transfer every service interval. valid only for periodic EPs.</span>
  </pre></dt>
<dd>
A structure representing the superspeed endpoint companion descriptor. This descriptor is documented in section 9.6.7 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L337"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbBosDevCapabilityDescriptor"><a name="LibusbBosDevCapabilityDescriptor"></a><pre><span class="Identifier">LibusbBosDevCapabilityDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type</span>
                              <span class="Comment">## (`LibusbDescriptorType.device &lt;#LibusbDescriptorType&gt;`_).</span>
  <span class="Identifier">devCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Device Capability type.</span>
  <span class="Identifier">devCapabilityData</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">uint8</span><span class="Other">]</span> <span class="Comment">## Device Capability data</span>
                                      <span class="Comment">## (`length` - 3 bytes).</span>
  </pre></dt>
<dd>
Generic representation of a BOS Device Capability descriptor. It is advised to check <cite>devCapabilityType</cite> and call the matching <cite>libusbGetXXXDescriptor</cite> function to get a structure fully matching the type.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L354"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbBosDescriptor"><a name="LibusbBosDescriptor"></a><pre><span class="Identifier">LibusbBosDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes) </span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type (LIBUSB_DT_BOS).</span>
  <span class="Identifier">totalLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>        <span class="Comment">## Length of this descriptor and all of its sub</span>
                              <span class="Comment">## descriptors.</span>
  <span class="Identifier">numDeviceCaps</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>       <span class="Comment">## The number of separate device capability</span>
                              <span class="Comment">## descriptors in the BOS.</span>
  <span class="Identifier">devCapability</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">,</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDevCapabilityDescriptor</span><span class="Other">]</span> <span class="Comment">## \</span>
                                                                 <span class="Comment">## `bNumDeviceCap` Device Capability Descriptors.</span>
  </pre></dt>
<dd>
Binary Device Object Store (BOS) descriptor. This descriptor is documented in section 9.6.2 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L367"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbUsb20extensionDescriptor"><a name="LibusbUsb20extensionDescriptor"></a><pre><span class="Identifier">LibusbUsb20extensionDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type</span>
                              <span class="Comment">## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).</span>
  <span class="Identifier">devCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Capability type (LIBUSB_BT_USB_2_0_EXTENSION).</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Comment">## Bitmap encoding of supported device level</span>
                        <span class="Comment">## features. A value of one in a bit location indicates a feature is</span>
                        <span class="Comment">## supported; a  value of zero indicates it is not supported. See</span>
                        <span class="Comment">## `LibusbUsb20ExtensionAttributes &lt;#LibusbUsb20ExtensionAttributes&gt;`_.</span>
  </pre></dt>
<dd>
USB 2.0 Extension descriptor. This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification. All multiple-byte fields are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L381"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbSsUsbDeviceCapabilityDescriptor"><a name="LibusbSsUsbDeviceCapabilityDescriptor"></a><pre><span class="Identifier">LibusbSsUsbDeviceCapabilityDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type</span>
                              <span class="Comment">## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).</span>
  <span class="Identifier">devCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Capability type</span>
                              <span class="Comment">## (LIBUSB_BT_SS_USB_DEVICE_CAPABILITY).</span>
  <span class="Identifier">bmAttributes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Bitmap encoding of supported device level features.</span>
                       <span class="Comment">## A value of one in a bit location indicates a feature is supported; a</span>
                       <span class="Comment">## value of zero indicates it is not supported. See</span>
                       <span class="Comment">## `LibusbSsUsbDeviceCapabilityAttributes &lt;#LibusbSsUsbDeviceCapabilityAttributes&gt;`_.</span>
  <span class="Identifier">speedSupported</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>     <span class="Comment">## Bitmap encoding of the speed supported by this</span>
                              <span class="Comment">## device when operating in SuperSpeed mode. See</span>
                              <span class="Comment">## `LibusbSupportedSpeed &lt;#LibusbSupportedSpeed&gt;`_.</span>
  <span class="Identifier">functionalitySupport</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## The lowest speed at which all the</span>
                               <span class="Comment">## functionality supported by the device is available to the user.</span>
                               <span class="Comment">## For example if the device supports all its functionality when connected</span>
                               <span class="Comment">## at full speed and above then it sets this value to 1.</span>
  <span class="Identifier">u1DevExitLat</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>        <span class="Comment">## U1 Device Exit Latency.</span>
  <span class="Identifier">u2DevExitLat</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>       <span class="Comment">## U2 Device Exit Latency.</span>
  </pre></dt>
<dd>
Container ID descriptor. This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification. All multiple-byte fields, except UUIDs, are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L395"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbContainerIdDescriptor"><a name="LibusbContainerIdDescriptor"></a><pre><span class="Identifier">LibusbContainerIdDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>              <span class="Comment">## Size of this descriptor (in bytes).</span>
  <span class="Identifier">descriptorType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>      <span class="Comment">## Descriptor type</span>
                              <span class="Comment">## (`LibusbDescriptorType.deviceCapability &lt;#LibusbDescriptorType&gt;`_).</span>
  <span class="Identifier">devCapabilityType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>   <span class="Comment">## Capability type (LIBUSB_BT_CONTAINER_ID).</span>
  <span class="Identifier">reserved</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>            <span class="Comment">## Reserved for future use.</span>
  <span class="Identifier">containerID</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">16</span><span class="Other">,</span> <span class="Identifier">uint8</span><span class="Other">]</span> <span class="Comment">## 128 bit UUID.</span>
  </pre></dt>
<dd>
A structure representing the Container ID descriptor. This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification. All multiple-byte fields, except UUIDs, are represented in host-endian format.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L419"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbControlSetup"><a name="LibusbControlSetup"></a><pre><span class="Identifier">LibusbControlSetup</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">bmRequestType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Request type. Bits 0:4 determine recipient, see</span>
                        <span class="Comment">## `LibusbRequestRecipient`. Bits 5:6 determine type, see</span>
                        <span class="Comment">## `LibusbRequestType`. Bit 7 determines data transfer direction, see</span>
                        <span class="Comment">## `LibusbEndpointDirection &lt;#LibusbEndpointDirection&gt;`_.</span>
  <span class="Identifier">request</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Comment">## Request. If the type bits of `bmRequestType` are equal</span>
                  <span class="Comment">## to `LIBUSB_REQUEST_TYPE_STANDARD` then this field refers to</span>
                  <span class="Comment">## `LibusbStandardRequest`. For other cases, use of this field is</span>
                  <span class="Comment">## application-specific.</span>
  <span class="Identifier">value</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Value. Varies according to request.</span>
  <span class="Identifier">index</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Comment">## Index. Varies according to request, typically used to</span>
                 <span class="Comment">## pass an index or offset</span>
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>             <span class="Comment">## Number of bytes to transfer.</span>
  </pre></dt>
<dd>
Setup packet for control transfers.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L431"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbVersion"><a name="LibusbVersion"></a><pre><span class="Identifier">LibusbVersion</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">major</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library major version.</span>
  <span class="Identifier">minor</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library minor version.</span>
  <span class="Identifier">micro</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>              <span class="Comment">## Library micro version.</span>
  <span class="Identifier">nano</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint16</span>               <span class="Comment">## Library nano version.</span>
  <span class="Identifier">rc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>                <span class="Comment">## Library release candidate suffix string, e.g. &quot;-rc4&quot;.</span>
  <span class="Identifier">describe</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>          <span class="Comment">## For ABI compatibility only.</span>
  </pre></dt>
<dd>
Provides the version of the libusb runtime.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L448"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbContext"><a name="LibusbContext"></a><pre><span class="Identifier">LibusbContext</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
<p>Structure representing a libusb session. The concept of individual libusb sessions allows for your program to use two libraries (or dynamically load two modules) which both independently use libusb. This will prevent interference between the individual libusb users - for example <a class="reference external" href="#libusbSetDebug">libusbSetDebug</a> will not affect the other user of the library, and <a class="reference external" href="#libusbExit">libusbExit</a> will not destroy resources that the other user is still using.</p>
<p>Sessions are created by <a class="reference external" href="#libusbInit">libusbInit</a> and destroyed through <a class="reference external" href="#libusbExit">libusbExit</a>. If your application is guaranteed to only ever include a single libusb user (i.e. you), you do not have to worry about contexts: pass <tt class="docutils literal"><span class="pre">nil</span></tt> in every function call where a context is required. The default context will be used.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L458"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbDevice"><a name="LibusbDevice"></a><pre><span class="Identifier">LibusbDevice</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
<p>Structure representing a USB device detected on the system. This is an opaque type for which you are only ever provided with a pointer, usually originating from <cite>libusbGetDeviceList()</cite>.</p>
<p>Certain operations can be performed on a device, but in order to do any I/O you will have to first obtain a device handle using <a class="reference external" href="#libusbOpen">libusbOpen</a>.</p>
<p>Devices are reference counted with <cite>libusbRefDevice()</cite> and <a class="reference external" href="#libusbUnrefDevice">libusbUnrefDevice</a>, and are freed when the reference count reaches <tt class="docutils literal"><span class="pre">0</span></tt>. New devices presented by <a class="reference external" href="#libusbGetDeviceList">libusbGetDeviceList</a> have a reference count of <tt class="docutils literal"><span class="pre">1</span></tt>, and <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a> can optionally decrease the reference count on all devices in the list. <a class="reference external" href="#libusbOpen">libusbOpen</a> adds another reference which is later destroyed by <a class="reference external" href="#libusbClose">libusbClose</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L474"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbDeviceArray"><a name="LibusbDeviceArray"></a><pre><span class="Identifier">LibusbDeviceArray</span> <span class="Other">=</span> <span class="Identifier">array</span><span class="Other">[</span><span class="DecNumber">10000</span><span class="Other">,</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">]</span></pre></dt>
<dd>
Unchecked array of pointers to USB devices.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L492"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbDeviceHandle"><a name="LibusbDeviceHandle"></a><pre><span class="Identifier">LibusbDeviceHandle</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  </pre></dt>
<dd>
Represents USB device handle. This is an opaque type for which you are only ever provided with a pointer, usually originating from <cite>libusbOpen()</cite>. A device handle is used to perform I/O and other operations. When finished with a device handle, you should call <a class="reference external" href="#libusbClose">libusbClose</a>.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L495"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbSpeed"><a name="LibusbSpeed"></a><pre><span class="Identifier">LibusbSpeed</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">unknown</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>                <span class="Comment">## The OS doesn't report or know the device speed.</span>
  <span class="Identifier">lowSpeed</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>               <span class="Comment">## The device is operating at low speed (1.5MBit/s).</span>
  <span class="Identifier">fullSpeed</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>              <span class="Comment">## The device is operating at full speed (12MBit/s).</span>
  <span class="Identifier">highSpeed</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>              <span class="Comment">## The device is operating at high speed (480MBit/s).</span>
  <span class="Identifier">superSpeed</span> <span class="Other">=</span> <span class="DecNumber">4</span>              <span class="Comment">##The device is operating at super speed (5000MBit/s).</span></pre></dt>
<dd>

Enumerates speed codes to indicate the speed of devices.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L504"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbSupportedSpeed"><a name="LibusbSupportedSpeed"></a><pre><span class="Identifier">LibusbSupportedSpeed</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">lowSpeed</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span>               <span class="Comment">## Low speed operation supported (1.5MBit/s).</span>
  <span class="Identifier">fullSpeed</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>              <span class="Comment">## Full speed operation supported (12MBit/s).</span>
  <span class="Identifier">highSpeed</span> <span class="Other">=</span> <span class="DecNumber">4</span><span class="Other">,</span>              <span class="Comment">## High speed operation supported (480MBit/s).</span>
  <span class="Identifier">superSpeed</span> <span class="Other">=</span> <span class="DecNumber">8</span>              <span class="Comment">## Superspeed operation supported (5000MBit/s).</span></pre></dt>
<dd>

Enumerates supported speeds in the <tt class="docutils literal"><span class="pre">speedSupported</span></tt> bit field.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L513"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbUsb20ExtensionAttributes"><a name="LibusbUsb20ExtensionAttributes"></a><pre><span class="Identifier">LibusbUsb20ExtensionAttributes</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">linkPowerMngmt</span> <span class="Other">=</span> <span class="DecNumber">2</span>          <span class="Comment">## Supports Link Power Management (LPM).</span></pre></dt>
<dd>

Masks for the bits of the <cite>bmAttributes</cite> field in <a class="reference external" href="#LibusbUsb20extensionDescriptor">LibusbUsb20extensionDescriptor</a>.`.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L521"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbSsUsbDeviceCapabilityAttributes"><a name="LibusbSsUsbDeviceCapabilityAttributes"></a><pre><span class="Identifier">LibusbSsUsbDeviceCapabilityAttributes</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">latencyToleranceMsg</span> <span class="Other">=</span> <span class="DecNumber">2</span>     <span class="Comment">## Supports Latency Tolerance Messages (LTM).</span></pre></dt>
<dd>

Masks for the bits of the <cite>bmAttributes</cite> field in <a class="reference external" href="#LibusbSsUsbDeviceCapabilityDescriptor">LibusbSsUsbDeviceCapabilityDescriptor</a>.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L527"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbBosType"><a name="LibusbBosType"></a><pre><span class="Identifier">LibusbBosType</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">wirelessUsbDeviceCapability</span> <span class="Other">=</span> <span class="DecNumber">1</span><span class="Other">,</span> <span class="Comment">## Wireless USB device capability.</span>
  <span class="Identifier">usb20Extension</span> <span class="Other">=</span> <span class="DecNumber">2</span><span class="Other">,</span>         <span class="Comment">## USB 2.0 extensions.</span>
  <span class="Identifier">ssUsbDeviceCapability</span> <span class="Other">=</span> <span class="DecNumber">3</span><span class="Other">,</span>  <span class="Comment">## SuperSpeed USB device capability.</span>
  <span class="Identifier">containerId</span> <span class="Other">=</span> <span class="DecNumber">4</span>             <span class="Comment">## Container ID type.</span></pre></dt>
<dd>

Enumerates USB capability types.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L533"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbError"><a name="LibusbError"></a><pre><span class="Identifier">LibusbError</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">other</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">99</span><span class="Other">,</span>               <span class="Comment">## Other error.</span>
  <span class="Identifier">notSupported</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">12</span><span class="Other">,</span> <span class="Comment">## Operation not supported or unimplemented on this \</span>
                       <span class="Comment">## platform.</span>
  <span class="Identifier">noMemory</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">11</span><span class="Other">,</span>            <span class="Comment">## Insufficient memory.</span>
  <span class="Identifier">interrupted</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">10</span><span class="Other">,</span>         <span class="Comment">## System call interrupted (perhaps due to signal) </span>
  <span class="Identifier">pipe</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">9</span><span class="Other">,</span>                 <span class="Comment">## Pipe error.</span>
  <span class="Identifier">overflow</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">8</span><span class="Other">,</span>             <span class="Comment">## Overflow.</span>
  <span class="Identifier">timeout</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">7</span><span class="Other">,</span>              <span class="Comment">## Operation timed out.</span>
  <span class="Identifier">busy</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">6</span><span class="Other">,</span>                 <span class="Comment">## Resource busy.</span>
  <span class="Identifier">notFound</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">5</span><span class="Other">,</span>             <span class="Comment">## Entity not found.</span>
  <span class="Identifier">noDevice</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">4</span><span class="Other">,</span>             <span class="Comment">## No such device (it may have been disconnected).</span>
  <span class="Identifier">access</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">3</span><span class="Other">,</span>               <span class="Comment">## Access denied (insufficient permissions)</span>
  <span class="Identifier">invalidParam</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">2</span><span class="Other">,</span>         <span class="Comment">## Invalid parameter.</span>
  <span class="Identifier">io</span> <span class="Other">=</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Other">,</span>                   <span class="Comment">## Input/output error.</span>
  <span class="Identifier">success</span> <span class="Other">=</span> <span class="DecNumber">0</span>                 <span class="Comment">## Success (no error).</span></pre></dt>
<dd>

Enumerates error codes.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L540"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbTransferStatus"><a name="LibusbTransferStatus"></a><pre><span class="Identifier">LibusbTransferStatus</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">completed</span><span class="Other">,</span> <span class="Comment">## Transfer completed without error. Note that this does not</span>
             <span class="Comment">## indicate that the entire amount of requested data was transferred.</span>
  <span class="Identifier">error</span><span class="Other">,</span>                      <span class="Comment">## Transfer failed.</span>
  <span class="Identifier">timedOut</span><span class="Other">,</span>                   <span class="Comment">## Transfer timed out.</span>
  <span class="Identifier">cancelled</span><span class="Other">,</span>                  <span class="Comment">## Transfer was cancelled.</span>
  <span class="Identifier">stall</span><span class="Other">,</span> <span class="Comment">## For bulk/interrupt endpoints: halt condition detected</span>
         <span class="Comment">## (endpoint stalled). For control endpoints: control request not</span>
         <span class="Comment">## supported.</span>
  <span class="Identifier">noDevice</span><span class="Other">,</span>                   <span class="Comment">## Device was disconnected.</span>
  <span class="Identifier">overflow</span>                    <span class="Comment">## Device sent more data than requested.</span></pre></dt>
<dd>

Enumerats transfer status codes.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L564"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbTransferFlags"><a name="LibusbTransferFlags"></a><pre><span class="Identifier">LibusbTransferFlags</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">shortNotOk</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">0</span><span class="Other">,</span>       <span class="Comment">## Report short frames as errors.</span>
  <span class="Identifier">freeBuffer</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">1</span><span class="Other">,</span>       <span class="Comment">## Automatically `free()` transfer</span>
                              <span class="Comment">## buffer during `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_</span>
  <span class="Identifier">freeTransfer</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">2</span><span class="Other">,</span> <span class="Comment">## Automatically call</span>
                          <span class="Comment">## `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_ after callback returns.</span>
                          <span class="Comment">## If this flag is set, it is illegal to call</span>
                          <span class="Comment">## `libusbFreeTransfer &lt;#libusbFreeTransfer&gt;`_ from your transfer</span>
                          <span class="Comment">## callback, as this will result in a double-free when this flag is acted</span>
                          <span class="Comment">## upon.</span>
  <span class="Identifier">addZeroPacket</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">3</span> <span class="Comment">## Terminate transfers that are a multiple of the</span>
                          <span class="Comment">## endpoint's `maxPacketSize &lt;#LibusbEndpointDescriptor&gt;`_ with an extra</span>
                          <span class="Comment">## zero length packet. This is useful when a device protocol mandates that</span>
                          <span class="Comment">## each logical request is terminated by an incomplete packet (i.e. the</span>
                          <span class="Comment">## logical requests are not separated by other means).</span>
                          <span class="Comment">##</span>
                          <span class="Comment">## This flag only affects host-to-device transfers to bulk and interrupt</span>
                          <span class="Comment">## endpoints. In other situations, it is ignored.</span>
                          <span class="Comment">##</span>
                          <span class="Comment">## This flag only affects transfers with a length that is a multiple of </span>
                          <span class="Comment">## the endpoint's `maxPacketSize &lt;#LibusbEndpointDescriptor&gt;`_. On</span>
                          <span class="Comment">## transfers of other lengths, this flag has no effect. Therefore, if you</span>
                          <span class="Comment">## are working with a device that needs a ZLP whenever the end of the</span>
                          <span class="Comment">## logical request falls on a packet boundary, then it is sensible to set</span>
                          <span class="Comment">## this flag on every transfer (you do not have to worry about only</span>
                          <span class="Comment">## setting it on transfers that end on the boundary).</span>
                          <span class="Comment">##</span>
                          <span class="Comment">## This flag is currently only supported on Linux. On other systems,</span>
                          <span class="Comment">## `libusbSubmitTransfer &lt;#libusbSubmitTransfer&gt;`_ will return</span>
                          <span class="Comment">## `LibusbError.notSupported &lt;#LibusbError&gt;`_ for every transfer where this flag is set.</span></pre></dt>
<dd>

Enumerates <cite>libusb_transfer.flags</cite> values.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L578"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbIsoPacketDescriptor"><a name="LibusbIsoPacketDescriptor"></a><pre><span class="Identifier">LibusbIsoPacketDescriptor</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span>              <span class="Comment">## Length of data to request in this packet.</span>
  <span class="Identifier">actualLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span>        <span class="Comment">## Amount of data that was actually transferred.</span>
  <span class="Identifier">status</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">LibusbTransferStatus</span> <span class="Comment">## Status code for this packet.</span>
  </pre></dt>
<dd>
Isochronous packet descriptor.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L612"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbTransferCbFn"><a name="LibusbTransferCbFn"></a><pre><span class="Identifier">LibusbTransferCbFn</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">fastcall</span><span class="Other">.}</span></pre></dt>
<dd>
Asynchronous transfer callback function type. When submitting asynchronous transfers, you pass a pointer to a callback function of this type via the <tt class="docutils literal"><span class="pre">callback</span></tt> member of the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> object. libusb will call this function later, when the transfer has completed or failed.<dl class="docutils"><dt>transfer</dt>
<dd>The <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> object that the callback function is being notified about</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L625"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbTransfer"><a name="LibusbTransfer"></a><pre><span class="Identifier">LibusbTransfer</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">devHandle</span><span class="Operator">*</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span> <span class="Comment">## Handle of the device that this</span>
                                     <span class="Comment">## transfer will be submitted to.</span>
  <span class="Identifier">flags</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">uint8</span>               <span class="Comment">## A bitwise OR combination of</span>
                              <span class="Comment">## `LibusbTransferFlags &lt;#LibusbTransferFlags&gt;`_.</span>
  <span class="Identifier">endpoint</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuchar</span>           <span class="Comment">## Address of the endpoint where this transfer will be sent.</span>
  <span class="Identifier">transferType</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">LibusbTransferType</span> <span class="Comment">## Type of the endpoint from</span>
                                    <span class="Comment">## `LibusbTransferType &lt;#LibusbTransferType&gt;`_.</span>
  <span class="Identifier">timeout</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cuint</span> <span class="Comment">## Timeout for this transfer in millseconds. A value of 0</span>
                  <span class="Comment">## indicates no timeout.</span>
  <span class="Identifier">status</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">LibusbTransferStatus</span> <span class="Comment">## The status of the transfer. Read-only,</span>
                                <span class="Comment">## and only for use within transfer callback function.</span>
                                <span class="Comment">##</span>
                                <span class="Comment">## If this is an isochronous transfer, this field may read COMPLETED even</span>
                                <span class="Comment">## if there were errors in the frames. Use the</span>
                                <span class="Comment">## `LibusbIsoPacketDescriptor.status` field in each packet to determine</span>
                                <span class="Comment">## if errors occurred.</span>
  <span class="Identifier">length</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>               <span class="Comment">## Length of the data buffer.</span>
  <span class="Identifier">actualLength</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Comment">## Actual length of data that was transferred.</span>
                      <span class="Comment">## Read-only, and only for use within transfer callback function.</span>
                      <span class="Comment">## Not valid for isochronous endpoint transfers.</span>
  <span class="Identifier">callback</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span> <span class="Comment">## Callback function. This will be invoked</span>
                                <span class="Comment">## when the transfer completes, fails, or is cancelled.</span>
                                <span class="Comment">## TODO: convert this to Nim</span>
  <span class="Identifier">userData</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">pointer</span>          <span class="Comment">## User context data to pass to the callback function.</span>
  <span class="Identifier">buffer</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cstring</span>            <span class="Comment">## Data buffer.</span>
  <span class="Identifier">numIsoPackets</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Comment">## Number of isochronous packets. Only used for I/O</span>
                       <span class="Comment">## with isochronous endpoints.</span>
  <span class="Identifier">isoPacketDesc</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">LibusbIsoPacketDescriptorArray</span> <span class="Comment">## Isochronous packet</span>
                                                 <span class="Comment">## descriptors, for isochronous transfers only.</span>
  </pre></dt>
<dd>
Generic USB transfer structure. The user populates this structure and then submits it in order to request a transfer. After the transfer has completed, the library populates the transfer with the results and passes it back to the user.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L637"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbCapability"><a name="LibusbCapability"></a><pre><span class="Identifier">LibusbCapability</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">hasCapability</span> <span class="Other">=</span> <span class="DecNumber">0x00000000</span><span class="Other">,</span> <span class="Comment">## The libusbHasCapability() API</span>
                              <span class="Comment">## is available.</span>
  <span class="Identifier">hasHotplug</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span>    <span class="Comment">## Hotplug support is available on this</span>
                              <span class="Comment">## platform.</span>
  <span class="Identifier">hasHidAccess</span> <span class="Other">=</span> <span class="DecNumber">0x00000100</span><span class="Other">,</span> <span class="Comment">## The library can access HID</span>
                             <span class="Comment">## devices without requiring user intervention. Note that before being</span>
                             <span class="Comment">## able to actually access an HID device, you may still have to call</span>
                             <span class="Comment">## additional libusb functions such as</span>
                             <span class="Comment">## `libusbDetachKernelDriver &lt;#libusbDetachKernelDriver&gt;`_.</span>
  <span class="Identifier">supportsDetachKernelDriver</span> <span class="Other">=</span> <span class="DecNumber">0x00000101</span> <span class="Comment">## The library</span>
                                          <span class="Comment">## supports detaching of the default USB driver, using</span>
                                          <span class="Comment">## `libusbDetachKernelDriver &lt;#libusbDetachKernelDriver&gt;`_, if one is set</span>
                                          <span class="Comment">## by the OS kernel.</span></pre></dt>
<dd>

Enumerates capabilities supported by an instance of libusb on the current running platform. Test if the loaded library supports a given capability by calling <cite>libusbHasCapability()</cite>.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L674"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbLogLevel"><a name="LibusbLogLevel"></a><pre><span class="Identifier">LibusbLogLevel</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">none</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>                   <span class="Comment">## No messages ever printed by the library (default)</span>
  <span class="Identifier">error</span><span class="Other">,</span>                      <span class="Comment">## Error messages are printed to stderr</span>
  <span class="Identifier">warning</span><span class="Other">,</span>                    <span class="Comment">## Warning and error messages are printed to stderr</span>
  <span class="Identifier">info</span><span class="Other">,</span> <span class="Comment">## Informational messages are printed to stdout, warning and error</span>
        <span class="Comment">## messages are printed to stderr</span>
  <span class="Identifier">debug</span> <span class="Comment">## Debug and informational messages are printed to stdout, warnings</span>
        <span class="Comment">## and errors to stderr</span></pre></dt>
<dd>

Enumerates log message levels.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L693"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbPollfd"><a name="LibusbPollfd"></a><pre><span class="Identifier">LibusbPollfd</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">fd</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cint</span>                   <span class="Comment">## Numeric file descriptor </span>
  <span class="Identifier">events</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">cshort</span> <span class="Comment">## Event flags to poll for from &lt;poll.h&gt;. POLLIN indicates</span>
                  <span class="Comment">## that you should monitor this file descriptor for becoming ready to read</span>
                  <span class="Comment">## from, and POLLOUT indicates that you should monitor this file</span>
                  <span class="Comment">## descriptor for nonblocking write readiness. </span>
  </pre></dt>
<dd>
File descriptor for polling.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2706"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbPollfdAddedCb"><a name="LibusbPollfdAddedCb"></a><pre><span class="Identifier">LibusbPollfdAddedCb</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">fd</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">events</span><span class="Other">:</span> <span class="Identifier">cshort</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span></pre></dt>
<dd>
Callback function, invoked when a new file descriptor should be added to the set of file descriptors monitored for events.<dl class="docutils"><dt>fd</dt>
<dd>The new file descriptor</dd>
<dt>events</dt>
<dd>Events to monitor for (see <a class="reference external" href="#LibusbPollfd">LibusbPollfd</a> for details)</dd>
<dt>userData</dt>
<dd>User data pointer specified in the <a class="reference external" href="#libusbSetPollfdNotifiers">libusbSetPollfdNotifiers</a> call</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2716"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbPollfdRemovedCb"><a name="LibusbPollfdRemovedCb"></a><pre><span class="Identifier">LibusbPollfdRemovedCb</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">fd</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span></pre></dt>
<dd>
Callback function, invoked when a file descriptor should be removed from the set of file descriptors being monitored for events. After returning from this callback, do not use that file descriptor again.<dl class="docutils"><dt>fd</dt>
<dd>The file descriptor to stop monitoring</dd>
<dt>userData</dt>
<dd>User data pointer specified in their <a class="reference external" href="#libusbSetPollfdNotifiers">libusbSetPollfdNotifiers</a> call</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2730"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbHotplugCallbackHandle"><a name="LibusbHotplugCallbackHandle"></a><pre><span class="Identifier">LibusbHotplugCallbackHandle</span> <span class="Other">=</span> <span class="Identifier">cint</span></pre></dt>
<dd>
<p>Callback handle.</p>
<p>Callbacks handles are generated by <a class="reference external" href="#libusbHotplugRegisterCallback">libusbHotplugRegisterCallback</a> and can be used to deregister callbacks. Callback handles are unique per <a class="reference external" href="#LibusbContext">LibusbContext</a> and it is safe to call <a class="reference external" href="#libusbHotplugDeregisterCallback">libusbHotplugDeregisterCallback</a> on an already deregisted callback.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2790"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbHotplugFlag"><a name="LibusbHotplugFlag"></a><pre><span class="Identifier">LibusbHotplugFlag</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">noFlags</span> <span class="Other">=</span> <span class="DecNumber">0</span><span class="Other">,</span>                <span class="Comment">## Default value when not using any flags.</span>
  <span class="Identifier">enumerate</span> <span class="Other">=</span> <span class="DecNumber">1</span> <span class="Keyword">shl</span> <span class="DecNumber">0</span>         <span class="Comment">## Arm the callback and fire it for all</span>
                              <span class="Comment">## matching currently attached devices.</span></pre></dt>
<dd>

Enumerates flags for hotplug events.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2802"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbHotplugEvent"><a name="LibusbHotplugEvent"></a><pre><span class="Identifier">LibusbHotplugEvent</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">deviceArrived</span> <span class="Other">=</span> <span class="DecNumber">0x00000001</span><span class="Other">,</span> <span class="Comment">## A device has been plugged in and is ready to</span>
                              <span class="Comment">## use.</span>
  <span class="Identifier">deviceLeft</span> <span class="Other">=</span> <span class="DecNumber">0x00000002</span> <span class="Comment">## A device has left and is no longer available. It</span>
                          <span class="Comment">## is the user's responsibility to call `libusbClose &lt;#libusbClose&gt;`_ on</span>
                          <span class="Comment">## any handle associated with a disconnected device. It is safe to call</span>
                          <span class="Comment">## `libusbGetDeviceDescriptor &lt;#libusbGetDeviceDescriptor&gt;`_ on a device</span>
                          <span class="Comment">## that has left.</span></pre></dt>
<dd>

Enumerates hot plug events.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2810"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="LibusbHotplugCallbackFn"><a name="LibusbHotplugCallbackFn"></a><pre><span class="Identifier">LibusbHotplugCallbackFn</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
                                <span class="Identifier">device</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> 
                                <span class="Identifier">event</span><span class="Other">:</span> <span class="Identifier">LibusbHotplugEvent</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span></pre></dt>
<dd>
Hotplug callback function type. When requesting hotplug event notifications, you pass a pointer to a callback function of this type.<dl class="docutils"><dt>ctx</dt>
<dd>Context of this notification</dd>
<dt>device</dt>
<dd>The <a class="reference external" href="#LibusbDevice">LibusbDevice</a> this event occurred on</dd>
<dt>event</dt>
<dd>Event that occurred</dd>
<dt>userData</dt>
<dd>User data provided when this callback was registered</dd>
<dt>result</dt>
<dd><ul class="simple"><li>bool whether this callback is finished processing events; returning 1 will cause this callback to be deregistered</li>
</ul>
</dd>
</dl>
<p>This callback may be called by an internal event thread and as such it is recommended the callback do minimal processing before returning. libusb will call this function later, when a matching event had happened on a matching device.</p>
<p>It is safe to call either <a class="reference external" href="#libusbHotplugRegisterCallback">libusbHotplugRegisterCallback</a> or <a class="reference external" href="#libusbHotplugDeregisterCallback">libusbHotplugDeregisterCallback</a> from within a callback function.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2826"
class="link-seesrc" target="_blank">Source</a>
</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<dt id="libusbApiVersion"><a name="libusbApiVersion"></a><pre><span class="Identifier">libusbApiVersion</span> <span class="Other">=</span> <span class="DecNumber">0x01000103</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L33"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtDeviceSize"><a name="libusbDtDeviceSize"></a><pre><span class="Identifier">libusbDtDeviceSize</span> <span class="Other">=</span> <span class="DecNumber">18</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L104"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtConfigSize"><a name="libusbDtConfigSize"></a><pre><span class="Identifier">libusbDtConfigSize</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L105"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtInterfaceSize"><a name="libusbDtInterfaceSize"></a><pre><span class="Identifier">libusbDtInterfaceSize</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L106"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtEndpointSize"><a name="libusbDtEndpointSize"></a><pre><span class="Identifier">libusbDtEndpointSize</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L107"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtEndpointAudioSize"><a name="libusbDtEndpointAudioSize"></a><pre><span class="Identifier">libusbDtEndpointAudioSize</span> <span class="Other">=</span> <span class="DecNumber">9</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L108"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtHubNonvarSize"><a name="libusbDtHubNonvarSize"></a><pre><span class="Identifier">libusbDtHubNonvarSize</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L109"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtSsEndpointCompanionSize"><a name="libusbDtSsEndpointCompanionSize"></a><pre><span class="Identifier">libusbDtSsEndpointCompanionSize</span> <span class="Other">=</span> <span class="DecNumber">6</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L110"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtBosSize"><a name="libusbDtBosSize"></a><pre><span class="Identifier">libusbDtBosSize</span> <span class="Other">=</span> <span class="DecNumber">5</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L111"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtDeviceCapabilitySize"><a name="libusbDtDeviceCapabilitySize"></a><pre><span class="Identifier">libusbDtDeviceCapabilitySize</span> <span class="Other">=</span> <span class="DecNumber">3</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L112"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbBtUsb20ExtensionSize"><a name="libusbBtUsb20ExtensionSize"></a><pre><span class="Identifier">libusbBtUsb20ExtensionSize</span> <span class="Other">=</span> <span class="DecNumber">7</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L116"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbBtSsUsbDeviceCapabilitySize"><a name="libusbBtSsUsbDeviceCapabilitySize"></a><pre><span class="Identifier">libusbBtSsUsbDeviceCapabilitySize</span> <span class="Other">=</span> <span class="DecNumber">10</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L117"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbBtContainerIdSize"><a name="libusbBtContainerIdSize"></a><pre><span class="Identifier">libusbBtContainerIdSize</span> <span class="Other">=</span> <span class="DecNumber">20</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L118"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDtBosMaxSize"><a name="libusbDtBosMaxSize"></a><pre><span class="Identifier">libusbDtBosMaxSize</span> <span class="Other">=</span> <span class="DecNumber">42</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L122"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbEndpointAddressMask"><a name="libusbEndpointAddressMask"></a><pre><span class="Identifier">libusbEndpointAddressMask</span> <span class="Other">=</span> <span class="DecNumber">0x0000000F</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L126"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbEndpointDirMask"><a name="libusbEndpointDirMask"></a><pre><span class="Identifier">libusbEndpointDirMask</span> <span class="Other">=</span> <span class="DecNumber">0x00000080</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L127"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbTransferTypeMask"><a name="libusbTransferTypeMask"></a><pre><span class="Identifier">libusbTransferTypeMask</span> <span class="Other">=</span> <span class="DecNumber">0x00000003</span></pre></dt>
<dd>
Used in <cite>bmAttributes</cite> fields.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L140"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbIsoSyncTypeMask"><a name="libusbIsoSyncTypeMask"></a><pre><span class="Identifier">libusbIsoSyncTypeMask</span> <span class="Other">=</span> <span class="DecNumber">0x0000000C</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L194"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbIsoUsageTypeMask"><a name="libusbIsoUsageTypeMask"></a><pre><span class="Identifier">libusbIsoUsageTypeMask</span> <span class="Other">=</span> <span class="DecNumber">0x00000030</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L206"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbErrorCount"><a name="libusbErrorCount"></a><pre><span class="Identifier">libusbErrorCount</span> <span class="Other">=</span> <span class="DecNumber">14</span></pre></dt>
<dd>
Total number of error codes in 
<a class="reference external" href="#LibusbError">libusb_error</a>.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L559"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHotplugMatchAny"><a name="libusbHotplugMatchAny"></a><pre><span class="Identifier">libusbHotplugMatchAny</span> <span class="Other">=</span> <span class="DecNumber">-1</span></pre></dt>
<dd>
Wildcard matching for hotplug events.
&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2822"
class="link-seesrc" target="_blank">Source</a>
</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<dt id="libusbCpuToLe16"><a name="libusbCpuToLe16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbCpuToLe16</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint16</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convert a 16-bit value from host-endian to little-endian format.<dl class="docutils"><dt>x</dt>
<dd>The value to convert</dd>
<dt>result</dt>
<dd>The converted value</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L36"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbInit"><a name="libusbInit,ptr.ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbInit</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_init&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Initializes libusb.<dl class="docutils"><dt>context</dt>
<dd>Optional output location for context pointer. Only valid on return code <tt class="docutils literal"><span class="pre">0</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on failure</li>
</ul>
</dd>
</dl>
<p>This function must be called before calling any other libusb function. If you do not provide an output location for a context pointer, a default context will be created. If there was already a default context, it will be reused (and nothing will be initialized/reinitialized).</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L704"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbExit"><a name="libusbExit,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbExit</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_exit&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Shuts down libusb.<dl class="docutils"><dt>ctx</dt>
<dd>The context to deinitialize, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context.</dd>
</dl>
<p>Should be called after closing all open devices and before your application terminates.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L721"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetDebug"><a name="libusbSetDebug,ptr.LibusbContext,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetDebug</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">level</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_debug&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Sets the log message verbosity.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>level</dt>
<dd>The debug level to set</dd>
</dl>
<p>The default level is <a class="reference external" href="#LibusbLogLevel">LibusbLogLevel.none</a>, which means no messages are ever printed. If you choose to increase the message verbosity level, ensure that your application does not close the stdout / stderr file descriptors.</p>
<p>You are advised to use level <a class="reference external" href="#LibusbLogLevel">LibusbLogLevel.warning</a>. libusb is conservative with its message logging and most of the time, will only log messages that explain error conditions and other oddities. This will help you debug your software.</p>
<p>If the <tt class="docutils literal"><span class="pre">LIBUSB_DEBUG</span></tt> environment variable was set when libusb was initialized, this function does nothing: the message verbosity is fixed to the value in the environment variable.</p>
<p>If libusb was compiled without any message logging, this function does nothing: you'll never get any messages. If libusb was compiled with verbose debug message logging, this function does nothing: you'll always get messages from all levels.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L732"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetVersion"><a name="libusbGetVersion,"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetVersion</span><span class="Other">(</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbVersion</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_version&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets the version (major, minor, micro, nano and rc) of the running library.<dl class="docutils"><dt>result</dt>
<dd>An object containing the version number</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L761"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHasCapability"><a name="libusbHasCapability,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHasCapability</span><span class="Other">(</span><span class="Identifier">capability</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_has_capability&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Checks at runtime if the loaded library has a given capability.<dl class="docutils"><dt>capability</dt>
<dd>The <a class="reference external" href="#LibusbCapability">LibusbCapability</a> to check for</dd>
<dt>result</dt>
<dd><ul class="simple"><li>nonzero if the running library has the capability</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> otherwise.</li>
</ul>
</dd>
</dl>
<p>This call should be performed after <a class="reference external" href="#libusbInit">libusbInit</a>, to ensure that the backend has updated its capability set.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L769"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbErrorName"><a name="libusbErrorName,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbErrorName</span><span class="Other">(</span><span class="Identifier">errcode</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_error_name&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a constant nil-terminated string with the ASCII name of a libusb error or transfer status code.<dl class="docutils"><dt>error_code</dt>
<dd>The <a class="reference external" href="#LibusbError">LibusbError</a> or <a class="reference external" href="#LibusbTransferStatus">LibusbTransferStatus</a> code</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The error name if <cite>errcode</cite> is known</li>
<li><cite>&quot;UNKNOWN&quot;</cite> if the value of <cite>errcode</cite> is not a known code</li>
</ul>
</dd>
</dl>
<p>The caller must not free the returned string.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L783"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetLocale"><a name="libusbSetLocale,cstring"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetLocale</span><span class="Other">(</span><span class="Identifier">locale</span><span class="Other">:</span> <span class="Identifier">cstring</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_setlocale&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set the language, and only the language, not the encoding! used for translatable libusb messages.<dl class="docutils"><dt>locale</dt>
<dd>The locale-string in the form of <tt class="docutils literal"><span class="pre">lang[_country_region][.codeset]</span></tt> or <tt class="docutils literal"><span class="pre">lang[-region]</span></tt>, where lang is a 2 letter ISO 639-1 code.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><a class="reference external" href="#LibusbError">LibusbError.success</a> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.invalidParam</a> if the locale doesn't meet the requirements</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the requested language is not supported</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on other errors.</li>
</ul>
</dd>
</dl>
<p>This takes a locale string in the default setlocale format:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">lang[-region]</span></tt>, or</li>
<li><tt class="docutils literal"><span class="pre">lang[_country_region][.codeset]</span></tt>.</li>
</ul>
<p>Only the <cite>lang</cite> part of the string is used, and only 2 letter ISO 639-1 codes are accepted for it, such as &quot;de&quot;. The optional region, <cite>country_region</cite> or <cite>codeset</cite> parts are ignored. This means that functions which return translatable strings will NOT honor the specified encoding.</p>
<p>All strings returned are encoded as UTF-8 strings. If <a class="reference external" href="#libusbSetLocale">libusbSetLocale</a> is not called, all messages will be in English. Note that the libusb log messages controlled through <a class="reference external" href="#libusbSetDebug">libusbSetDebug</a> are not translated, they are always in English.</p>
<p>The following functions return translatable strings:</p>
<ul class="simple"><li><a class="reference external" href="#libusbStrError">libusbStrError</a></li>
</ul>
<p>For POSIX UTF-8 environments if you want libusb to follow the standard locale settings, call <cite>libusbSetLocale(setlocale(LC_MESSAGES, nil))</cite>, after your app has done its locale setup.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L798"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbStrError"><a name="libusbStrError,LibusbError"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbStrError</span><span class="Other">(</span><span class="Identifier">errcode</span><span class="Other">:</span> <span class="Identifier">LibusbError</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cstring</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_strerror&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get a constant string with a short description of the given error code.<dl class="docutils"><dt>errcode</dt>
<dd>The error code whose description is desired</dd>
<dt>result</dt>
<dd><ul class="simple"><li>A short description of the error code in UTF-8 encoding.</li>
</ul>
</dd>
</dl>
<p>This description is intended for displaying to the end user and will be in the language set by <a class="reference external" href="#libusbSetLocale">libusbSetLocale</a>. The returned string is encoded in UTF-8. The messages always start with a capital letter and end without any dot. The caller must not free the returned string.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L837"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDeviceList"><a name="libusbGetDeviceList,ptr.LibusbContext,ptr.ptr.LibusbDeviceArray"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDeviceList</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">list</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceArray</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">csize</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_list&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get a list of USB devices currently attached to the system.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>list</dt>
<dd>The output location for a list of devices. Must be later freed with <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a></dd>
<dt>result</dt>
<dd><ul class="simple"><li>the number of devices in the outputted list</li>
<li>any <a class="reference external" href="#LibusbError">LibusbError</a> according to errors encountered by the backend</li>
</ul>
</dd>
</dl>
<p>This is your entry point into finding a USB device to operate. You are expected to unreference all the devices when you are done with them, and then free the list with <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a>.</p>
<p>Note that <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a> can unref all the devices for you. Be careful not to unreference a device you are about to open until after you have opened it.</p>
<p>The return value of this function indicates the number of devices in the resultant list. The list is actually one element larger, as it is NULL-terminated.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L852"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeDeviceList"><a name="libusbFreeDeviceList,ptr.LibusbDeviceArray,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeDeviceList</span><span class="Other">(</span><span class="Identifier">list</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceArray</span><span class="Other">;</span> <span class="Identifier">unrefDevices</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_device_list&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free a list of devices previously discovered using <a class="reference external" href="#libusbGetDeviceList">libusbGetDeviceList</a>.<dl class="docutils"><dt>list</dt>
<dd>The list to free</dd>
<dt>unrefDevices</dt>
<dd>Whether to unref the devices in the list</dd>
</dl>
<p>If the <cite>unrefDevices</cite> parameter is set, the reference count of each device in the list is decremented by <tt class="docutils literal"><span class="pre">1</span></tt>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L880"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbRefDevice"><a name="libusbRefDevice,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbRefDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_ref_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Increment the reference count of a device.<dl class="docutils"><dt>dev</dt>
<dd>The device to reference</dd>
<dt>result</dt>
<dd>The same device</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L894"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbUnrefDevice"><a name="libusbUnrefDevice,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbUnrefDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unref_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Decrement the reference count of a device.<dl class="docutils"><dt>dev</dt>
<dd>The device to unreference</dd>
</dl>
<p>If the decrement operation causes the reference count to reach zero, the device shall be destroyed.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L904"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetConfiguration"><a name="libusbGetConfiguration,ptr.LibusbDeviceHandle,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetConfiguration</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_configuration&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine the configuration value of the currently active configuration.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>config</dt>
<dd>Output location for the <a class="reference external" href="#LibusbConfigDescriptor">configurationValue</a> of the active configuration (only valid for return code <tt class="docutils literal"><span class="pre">0</span></tt>)</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other failures</li>
</ul>
</dd>
</dl>
<p>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information. This function will return a value of 0 in the config output parameter if the device is in unconfigured state.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L915"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDeviceDescriptor"><a name="libusbGetDeviceDescriptor,ptr.LibusbDevice,ptr.LibusbDeviceDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDeviceDescriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> 
                               <span class="Identifier">desc</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the USB device descriptor for a given device.<dl class="docutils"><dt>dev</dt>
<dd>The device</dd>
<dt>desc</dt>
<dd>Output location for the descriptor data</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on failure</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function; the device descriptor is cached in memory. Note since libusb-1.0.16, <a class="reference external" href="#libusbApiVersion">libusbApiVersion</a> &gt;= 0x01000102, this function always succeeds.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L941"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetActiveConfigDescriptor"><a name="libusbGetActiveConfigDescriptor,ptr.LibusbDevice,ptr.ptr.LibusbConfigDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetActiveConfigDescriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> 
                                     <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbConfigDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_active_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the USB configuration descriptor for the currently active configuration.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>config</dt>
<dd>Output location for the USB configuration descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeConfigDescriptor">libusbFreeConfigDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the device is in unconfigured state</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L959"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetConfigDescriptor"><a name="libusbGetConfigDescriptor,ptr.LibusbDevice,uint8,ptr.ptr.LibusbConfigDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetConfigDescriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> <span class="Identifier">config_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                               <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbConfigDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get a USB configuration descriptor based on its index.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>config_index</dt>
<dd>The index of the configuration you wish to retrieve</dd>
<dt>config</dt>
<dd>Output location for the USB configuration descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeConfigDescriptor">libusbFreeConfigDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the configuration does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L981"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetConfigDescriptorByValue"><a name="libusbGetConfigDescriptorByValue,ptr.LibusbDevice,uint8,ptr.ptr.LibusbConfigDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetConfigDescriptorByValue</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> 
                                      <span class="Identifier">configurationValue</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                                      <span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbConfigDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_config_descriptor_by_value&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a USB configuration descriptor with a specific configuration value.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>configurationValue</dt>
<dd>The <a class="reference external" href="#LibusbConfigDescriptor">configurationValue</a> of the configuration you wish to retrieve</dd>
<dt>config</dt>
<dd>Output location for the USB configuration descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeConfigDescriptor">libusbFreeConfigDescriptor</a> after use</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the configuration does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1004"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeConfigDescriptor"><a name="libusbFreeConfigDescriptor,ptr.LibusbConfigDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeConfigDescriptor</span><span class="Other">(</span><span class="Identifier">config</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbConfigDescriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_config_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a configuration descriptor obtained from <a class="reference external" href="#libusbGetActiveConfigDescriptor">libusbGetActiveConfigDescriptor</a> or <a class="reference external" href="#libusbGetConfigDescriptor">libusbGetConfigDescriptor</a>.<dl class="docutils"><dt>config</dt>
<dd>The configuration descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> config parameter, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1028"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetSsEndpointCompanionDescriptor"><a name="libusbGetSsEndpointCompanionDescriptor,ptr.LibusbContext,ptr.LibusbEndpointDescriptor,ptr.ptr.LibusbSsEndpointCompanionDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetSsEndpointCompanionDescriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
    <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbEndpointDescriptor</span><span class="Other">;</span> 
    <span class="Identifier">ep_comp</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbSsEndpointCompanionDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_ss_endpoint_companion_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets an endpoints superspeed endpoint companion descriptor (if any).<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context.</dd>
<dt>endpoint</dt>
<dd>Endpoint descriptor from which to get the superspeed endpoint companion descriptor</dd>
<dt>ep_comp</dt>
<dd>Output location for the superspeed endpoint companion descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeSsEndpointCompanionDescriptor">libusbFreeSsEndpointCompanionDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the configuration does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other errors</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1041"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeSsEndpointCompanionDescriptor"><a name="libusbFreeSsEndpointCompanionDescriptor,ptr.LibusbSsEndpointCompanionDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeSsEndpointCompanionDescriptor</span><span class="Other">(</span>
    <span class="Identifier">ep_comp</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbSsEndpointCompanionDescriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_ss_endpoint_companion_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free a superspeed endpoint companion descriptor obtained from <a class="reference external" href="#libusbGetSsEndpointCompanionDescriptor">libusbGetSsEndpointCompanionDescriptor</a>.<dl class="docutils"><dt>ep_comp</dt>
<dd>The superspeed endpoint companion descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> <cite>ep_comp</cite> parameter, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1063"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetBosDescriptor"><a name="libusbGetBosDescriptor,ptr.LibusbDeviceHandle,ptr.ptr.LibusbBosDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetBosDescriptor</span><span class="Other">(</span><span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                            <span class="Identifier">bos</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_bos_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a Binary Object Store (BOS) descriptor.<dl class="docutils"><dt>handle</dt>
<dd>The handle of an open libusb device</dd>
<dt>bos</dt>
<dd>Output location for the BOS descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeBosDescriptor">libusbFreeBosDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the device doesn't have a BOS descriptor</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other errors</li>
</ul>
</dd>
</dl>
<p>This is a blocking function, which will send requests to the device.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1076"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeBosDescriptor"><a name="libusbFreeBosDescriptor,ptr.LibusbBosDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeBosDescriptor</span><span class="Other">(</span><span class="Identifier">bos</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDescriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_bos_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a BOS descriptor obtained from <cite>libusbGetBosDescriptor()</cite>.<dl class="docutils"><dt>bos</dt>
<dd>The BOS descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> <cite>bos</cite> parameter, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1096"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetUsb20ExtensionDescriptor"><a name="libusbGetUsb20ExtensionDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbUsb20extensionDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetUsb20ExtensionDescriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">devCap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDevCapabilityDescriptor</span><span class="Other">;</span> 
    <span class="Identifier">usb20Extension</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbUsb20extensionDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_usb_2_0_extension_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets an USB 2.0 Extension descriptor.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>devCap</dt>
<dd>Device Capability descriptor with a <cite>devCapabilityType</cite> of <tt class="docutils literal"><span class="pre">libusb_capability_type.extension</span></tt></dd>
<dt>usb20Extension</dt>
<dd>Output location for the USB 2.0 Extension descriptor. Only valid if <tt class="docutils literal"><span class="pre">0</span></tt> was returned. Must be freed with <a class="reference external" href="#libusbFreeUsb20ExtensionDescriptor">libusbFreeUsb20ExtensionDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on error</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1107"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeUsb20ExtensionDescriptor"><a name="libusbFreeUsb20ExtensionDescriptor,ptr.LibusbUsb20extensionDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeUsb20ExtensionDescriptor</span><span class="Other">(</span><span class="Identifier">usb20Extension</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbUsb20extensionDescriptor</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_usb_2_0_extension_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a USB 2.0 Extension descriptor obtained from <a class="reference external" href="#libusbGetUsb20ExtensionDescriptor">libusbGetUsb20ExtensionDescriptor</a>.<dl class="docutils"><dt>usb20Extension</dt>
<dd>The USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> <cite>usb20Extension</cite> parameter, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1128"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetSsUsbDeviceCapabilityDescriptor"><a name="libusbGetSsUsbDeviceCapabilityDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbSsUsbDeviceCapabilityDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetSsUsbDeviceCapabilityDescriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
    <span class="Identifier">devCap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDevCapabilityDescriptor</span><span class="Other">;</span> 
    <span class="Identifier">ssUsbDeviceCap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbSsUsbDeviceCapabilityDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_ss_usb_device_capability_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a SuperSpeed USB Device Capability descriptor.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>devCap</dt>
<dd>Device Capability descriptor with a <cite>devCapabilityType</cite> of <a class="reference external" href="#LibusbBosType">LibusbBosType.ssUsbDeviceCapability</a></dd>
<dt>ssUsbDeviceCap</dt>
<dd>Output location for the SuperSpeed USB Device Capability descriptor. Only valid if 0 was returned. Must be freed with <a class="reference external" href="#libusbFreeSsUsbDeviceCapabilityDescriptor">libusbFreeSsUsbDeviceCapabilityDescriptor</a> after use.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on error</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1141"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeSsUsbDeviceCapabilityDescriptor"><a name="libusbFreeSsUsbDeviceCapabilityDescriptor,ptr.LibusbSsUsbDeviceCapabilityDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeSsUsbDeviceCapabilityDescriptor</span><span class="Other">(</span>
    <span class="Identifier">ssUsbDeviceCap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbSsUsbDeviceCapabilityDescriptor</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_ss_usb_device_capability_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a SuperSpeed USB Device Capability descriptor obtained from <cite>libusbGetSsUsbDeviceCapabilityDescriptor()</cite>.<dl class="docutils"><dt>ssUsbDeviceCap</dt>
<dd>The USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> <cite>ssUsbDeviceCap parameter</cite>, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1162"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetContainerIdDescriptor"><a name="libusbGetContainerIdDescriptor,ptr.LibusbContext,ptr.LibusbBosDevCapabilityDescriptor,ptr.ptr.LibusbContainerIdDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetContainerIdDescriptor</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">devCap</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbBosDevCapabilityDescriptor</span><span class="Other">;</span> 
    <span class="Identifier">container_id</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContainerIdDescriptor</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_container_id_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets a Container ID descriptor.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>devCap</dt>
<dd>Device Capability descriptor with a <cite>devCapabilityType</cite> of <a class="reference external" href="#LibusbBosType">LibusbBosType.containerId</a></dd>
<dt>container_id</dt>
<dd>Output location for the Container ID descriptor. Only valid if 0 was returned. Must be freed with <a class="reference external" href="#libusbFreeContainerIdDescriptor">libusbFreeContainerIdDescriptor</a> after use</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on error</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1175"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeContainerIdDescriptor"><a name="libusbFreeContainerIdDescriptor,ptr.LibusbContainerIdDescriptor"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeContainerIdDescriptor</span><span class="Other">(</span><span class="Identifier">container_id</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContainerIdDescriptor</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_container_id_descriptor&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Frees a Container ID descriptor obtained from <a class="reference external" href="#libusbGetContainerIdDescriptor">libusbGetContainerIdDescriptor</a>.<dl class="docutils"><dt>container_id</dt>
<dd>The USB 2.0 Extension descriptor to free</dd>
</dl>
<p>It is safe to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> <cite>container_id</cite> parameter, in which case the function simply returns.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1196"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetBusNumber"><a name="libusbGetBusNumber,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetBusNumber</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_bus_number&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Gets the number of the bus that a device is connected to.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>result</dt>
<dd>The bus number</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1209"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetPortNumber"><a name="libusbGetPortNumber,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetPortNumber</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_port_number&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the number of the port that a device is connected to.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>result</dt>
<dd>The port number (0 if not available)</dd>
</dl>
<p>Unless the OS does something funky, or you are hot-plugging USB extension cards, the port number returned by this call is usually guaranteed to be uniquely tied to a physical port, meaning that different devices plugged on the same physical port should return the same port number.</p>
<p>But outside of this, there is no guarantee that the port number returned by this call will remain the same, or even match the order in which ports have been numbered by the HUB/HCD manufacturer.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1219"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetPortNumbers"><a name="libusbGetPortNumbers,ptr.LibusbDevice,ptr.uint8,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetPortNumbers</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> <span class="Identifier">port_numbers</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                          <span class="Identifier">port_numbers_len</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_port_numbers&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the list of all port numbers from root for the specified device.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>port_numbers</dt>
<dd>The array that should contain the port numbers</dd>
<dt>port_numbers_len</dt>
<dd>The maximum length of the array. As per the USB 3.0 specs, the current maximum limit for the depth is 7</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The number of elements filled</li>
<li><a class="reference external" href="#LibusbError">LibusbError.overflow</a> if the array is too small.</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1238"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetParent"><a name="libusbGetParent,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetParent</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_parent&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the the parent from the specified device.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>reuslt</dt>
<dd><ul class="simple"><li>The device parent</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> if not available</li>
</ul>
</dd>
</dl>
<p>You should issue a <a class="reference external" href="#libusbGetDeviceList">libusbGetDeviceList</a> before calling this function and make sure that you only access the parent before issuing <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a>. The reason is that libusb currently does not maintain a permanent list of device instances, and therefore can only guarantee that parents are fully instantiated within a <a class="reference external" href="#libusbGetDeviceList">libusbGetDeviceList</a> - <a class="reference external" href="#libusbFreeDeviceList">libusbFreeDeviceList</a> block.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1255"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDeviceAddress"><a name="libusbGetDeviceAddress,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDeviceAddress</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint8</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_address&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the address of the device on the bus it is connected to.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>result</dt>
<dd>The device address</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1274"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDeviceSpeed"><a name="libusbGetDeviceSpeed,ptr.LibusbDevice"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDeviceSpeed</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device_speed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the negotiated connection speed for a device.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>result</dt>
<dd><ul class="simple"><li><a class="reference external" href="#LibusbSpeed">LibusbSpeed</a>, where <a class="reference external" href="#LibusbSpeed">LibusbSpeed.unknown</a> means that the OS doesn't know or doesn't support returning the negotiated speed.</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1284"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetMaxPacketSize"><a name="libusbGetMaxPacketSize,ptr.LibusbDevice,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetMaxPacketSize</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_max_packet_size&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to retrieve the <a class="reference external" href="#LibusbEndpointDescriptor">maxPacketSize</a> value for a particular endpoint in the active device configuration.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint in question</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The <a class="reference external" href="#LibusbEndpointDescriptor">maxPacketSize</a> value</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the endpoint does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.other</a> on other failure</li>
</ul>
</dd>
</dl>
<p>This function was originally intended to be of assistance when setting up isochronous transfers, but a design mistake resulted in this function instead. It simply returns the <a class="reference external" href="#LibusbEndpointDescriptor">maxPacketSize</a> value without considering its contents. If you're dealing with isochronous transfers, you probably want <a class="reference external" href="#libusbGetMaxIsoPacketSize">libusbGetMaxIsoPacketSize</a> instead.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1296"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetMaxIsoPacketSize"><a name="libusbGetMaxIsoPacketSize,ptr.LibusbDevice,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetMaxIsoPacketSize</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_max_iso_packet_size&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe.<dl class="docutils"><dt>dev</dt>
<dd>A device</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint in question</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The maximum packet size which can be sent/received on this endpoint</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the endpoint does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.other</a> on other failure</li>
</ul>
</dd>
</dl>
<p>Only the active configuration is examined. The calculation is based on the <a class="reference external" href="#LibusbEndpointDescriptor">maxPacketSize</a> field in the endpoint descriptor as described in section 9.6.6 in the USB 2.0 specifications.</p>
<p>If acting on an isochronous or interrupt endpoint, this function will multiply the value found in bits 0:10 by the number of transactions per microframe (determined by bits 11:12). Otherwise, this function just returns the numeric value found in bits 0:10.</p>
<p>This function is useful for setting up isochronous transfers, for example you might pass the return value from this function to <a class="reference external" href="#libusbSetIsoPacketLengths">libusbSetIsoPacketLengths</a> in order to set the length field of every isochronous packet in a transfer.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1319"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbOpen"><a name="libusbOpen,ptr.LibusbDevice,ptr.ptr.LibusbDeviceHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbOpen</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span><span class="Other">;</span> <span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_open&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Open a device and obtain a device handle.<dl class="docutils"><dt>dev</dt>
<dd>The device to open</dd>
<dt>handle</dt>
<dd>Output location for the returned device handle pointer. Only populated when the return code is <tt class="docutils literal"><span class="pre">0</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noMemory</a> on memory allocation failure</li>
<li><a class="reference external" href="#LibusbError">LibusbError.access</a> if the user has insufficient permissions</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>A handle allows you to perform I/O on the device in question. Internally, this function adds a reference to the device and makes it available to you through <a class="reference external" href="#libusbGetDevice">libusbGetDevice</a>. This reference is removed during <a class="reference external" href="#libusbClose">libusbClose</a>.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1348"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbClose"><a name="libusbClose,ptr.LibusbDeviceHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbClose</span><span class="Other">(</span><span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_close&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Close a device handle.<dl class="docutils"><dt>devHandle</dt>
<dd>The handle to close</dd>
</dl>
<p>Should be called on all open handles before your application exits. Internally, this function destroys the reference that was added by <a class="reference external" href="#libusbOpen">libusbOpen</a> on the given device.</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1374"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDevice"><a name="libusbGetDevice,ptr.LibusbDeviceHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDevice</span><span class="Other">(</span><span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDevice</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get the underlying device for a handle.<dl class="docutils"><dt>devHandle</dt>
<dd>A device handle</dd>
<dt>result</dt>
<dd>The underlying device</dd>
</dl>
<p>This function does not modify the reference count of the returned device, so do not feel compelled to unreference it when you are done.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1388"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetConfiguration"><a name="libusbSetConfiguration,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetConfiguration</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">configuration</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_configuration&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine the <tt class="docutils literal"><span class="pre">configurationValue</span></tt> of the currently active configuration.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>config</dt>
<dd>Output location for the <a class="reference external" href="#LibusbConfigDescriptor">configurationValue</a> of the active configuration (only valid for return code <tt class="docutils literal"><span class="pre">0</span></tt>).</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</p>
<p>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information. This function will return a value of 0 in the config output parameter if the device is in unconfigured state.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1401"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbClaimInterface"><a name="libusbClaimInterface,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbClaimInterface</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">interfaceNumber</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_claim_interface&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Claim an interface on a given device handle.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interfaceNumber</dt>
<dd>The interface number of the interface you wish to claim</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the requested interface does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.busy</a> if another program or driver has claimed the interface</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codeS on other failures</li>
</ul>
</dd>
</dl>
<p>You must claim the interface you wish to use before you can perform I/O on any of its endpoints. It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</p>
<p>If <cite>auto_detach_kernel_driver</cite> is set to 1 for dev, the kernel driver will be detached if necessary, on failure the detach error is returned. Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</p>
<p>This is a non-blocking function.</p>
<p>See also <a class="reference external" href="#libusbAttachIKernelDriver">libusbAttachIKernelDriver</a>, <a class="reference external" href="#libusbDetachKernelDriver">libusbDetachKernelDriver</a>, <a class="reference external" href="#libusbSetAutoDetachKernelDriver">libusbSetAutoDetachKernelDriver</a></p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1428"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbReleaseInterface"><a name="libusbReleaseInterface,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbReleaseInterface</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">interfaceNumber</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_release_interface&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release an interface previously claimed with <a class="reference external" href="#libusbClaimInterface">libusbClaimInterface</a>.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interfaceNumber</dt>
<dd>The interface number of the previously-claimed interface</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the interface was not claimed</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>You should release all claimed interfaces before closing a device handle. A <a class="reference external" href="#LibusbStandardRequest">setInterface</a> control request will be sent to the device, resetting interface state to the first alternate setting.</p>
<p>If <cite>auto_detach_kernel_driver</cite> is set to 1 for dev, the kernel driver will be re-attached after releasing the interface.</p>
<p>This is a blocking function.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1465"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbOpenDeviceWithVidPid"><a name="libusbOpenDeviceWithVidPid,ptr.LibusbContext,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbOpenDeviceWithVidPid</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">vendorId</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                                <span class="Identifier">product_id</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_open_device_with_vid_pid&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function for finding a device with a particular idVendor / idProduct combination.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>vendorId</dt>
<dd>The idVendor value to search for</dd>
<dt>productId</dt>
<dd>The idProduct value to search for</dd>
<dt>result</dt>
<dd><ul class="simple"><li>a handle for the first found device</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> on error or if the device could not be found.</li>
</ul>
</dd>
</dl>
<p>This function is intended for those scenarios where you are using libusb to knock up a quick test application - it allows you to avoid calling <a class="reference external" href="#libusbGetDeviceList">libusbGetDeviceList</a> and worrying about traversing or freeing the list. This function has limitations and is hence not intended for use in real applications: if multiple devices have the same IDs it will only give you the first one, etc.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1491"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetInterfaceAltSetting"><a name="libusbSetInterfaceAltSetting,ptr.LibusbDeviceHandle,cint,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetInterfaceAltSetting</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                                  <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                  <span class="Identifier">alternate_setting</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_interface_alt_setting&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Activate an alternate setting for an interface.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interface_number</dt>
<dd>The <tt class="docutils literal"><span class="pre">interfaceNumber</span></tt> of the previously-claimed interface</dd>
<dt>alternate_setting</dt>
<dd>The <tt class="docutils literal"><span class="pre">alternateSetting</span></tt> of the alternate setting to activate</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the interface was not claimed, or the requested alternate setting does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The interface must have been previously claimed with <cite>libusbClaimInterface &lt;#libusbClaimInterface&gt;</cite>. You should always use this function rather than formulating your own <a class="reference external" href="#LibusbStandardRequest">setInterface</a> control request. This is because the underlying operating system needs to know when such changes happen.</p>
<p>This is a blocking function.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1516"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbClearHalt"><a name="libusbClearHalt,ptr.LibusbDeviceHandle,cuchar"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbClearHalt</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_clear_halt&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Clear the halt/stall condition for an endpoint.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>endpoint</dt>
<dd>The endpoint to clear halt status</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the endpoint does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on other failure</li>
</ul>
</dd>
</dl>
<p>Endpoints with halt status are unable to receive or transmit data until the halt condition is stalled. You should cancel all pending transfers before attempting to clear the halt condition.</p>
<p>This is a blocking function.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1543"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbResetDevice"><a name="libusbResetDevice,ptr.LibusbDeviceHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbResetDevice</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_reset_device&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB port reset to reinitialize a device.<dl class="docutils"><dt>dev</dt>
<dd>A handle of the device to reset</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if re-enumeration is required, or if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The system will attempt to restore the previous configuration and alternate settings after the reset has completed. If the reset fails, the descriptors change, or the previous state cannot be restored, the device will appear to be disconnected and reconnected. This means that the device handle is no longer valid (you should close it) and rediscover the device. A return code of <a class="reference external" href="#LibusbError">LibusbError.notFound</a> indicates when this is the case.</p>
<p>This is a blocking function which usually incurs a noticeable delay.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1565"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbAllocStreams"><a name="libusbAllocStreams,ptr.LibusbDeviceHandle,uint32,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbAllocStreams</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">num_streams</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> 
                        <span class="Identifier">endpoints</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">num_endpoints</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_alloc_streams&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate up to num_streams usb bulk streams on the specified endpoints.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>num_streams</dt>
<dd>Number of streams to try to allocate</dd>
<dt>endpoints</dt>
<dd>Array of endpoints to allocate streams on</dd>
<dt>num_endpoints</dt>
<dd>Length of the endpoints array</dd>
<dt>result</dt>
<dd><ul class="simple"><li>number of streams allocated</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>This function takes an array of endpoints rather then a single endpoint because some protocols require that endpoints are setup with similar stream ids. All endpoints passed in must belong to the same interface.</p>
<p>Note this function may return less streams then requested. Also note that the same number of streams are allocated for each endpoint in the endpoint array. Stream id <tt class="docutils literal"><span class="pre">0</span></tt> is reserved, and should not be used to communicate with devices. If <a class="reference external" href="#libusbAllocStreams">libusbAllocStreams</a> returns with a value of <tt class="docutils literal"><span class="pre">N</span></tt>, you may use stream ids <tt class="docutils literal"><span class="pre">1</span></tt> to <tt class="docutils literal"><span class="pre">N</span></tt>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1587"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeStreams"><a name="libusbFreeStreams,ptr.LibusbDeviceHandle,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeStreams</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">endpoints</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                       <span class="Identifier">num_endpoints</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_streams&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free usb bulk streams allocated with <a class="reference external" href="#libusbAllocStreams">libusbAllocStreams</a>.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>endpoints</dt>
<dd>Array of endpoints to free streams on</dd>
<dt>num_endpoints</dt>
<dd>Length of the endpoints array</dd>
<dt>result</dt>
<dd><ul class="simple"><li><a class="reference external" href="#LibusbError">LibusbError.success</a> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>Note streams are automatically free-ed when releasing an interface.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1615"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbKernelDriverActive"><a name="libusbKernelDriverActive,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbKernelDriverActive</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                              <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_kernel_driver_active&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if a kernel driver is active on an interface.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interface_number</dt>
<dd>The interface to check</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> if no kernel driver is active</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> if a kernel driver is active</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notSupported</a> on platforms where the functionality is not available</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O. This functionality is not available on Windows.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1634"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbDetachKernelDriver"><a name="libusbDetachKernelDriver,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbDetachKernelDriver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                              <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_detach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Detach a kernel driver from an interface.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interface_number</dt>
<dd>The interface to detach the driver from</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if no kernel driver was active</li>
<li><a class="reference external" href="#LibusbError">LibusbError.invalidParam</a> if the interface does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notSupported</a> on platforms where the functionality is not available,</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>If successful, you will then be able to claim the interface and perform I/O. This functionality is not available on Darwin or Windows. Note that libusb itself also talks to the device through a special kernel driver, if this driver is already attached to the device, this call will not detach it and return <a class="reference external" href="#LibusbError">LibusbError.notFound</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1656"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbAttachIKernelDriver"><a name="libusbAttachIKernelDriver,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbAttachIKernelDriver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                               <span class="Identifier">interface_number</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_attach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Re-attach an interface's kernel driver, which was previously detached using <a class="reference external" href="#libusbDetachKernelDriver">libusbDetachKernelDriver</a>.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>interface_number</dt>
<dd>The interface to attach the driver from</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if no kernel driver was active</li>
<li><a class="reference external" href="#LibusbError">LibusbError.invalidParam</a> if the interface does not exist</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notSupported</a> on platforms where the functionality is not available</li>
<li><a class="reference external" href="#LibusbError">LibusbError.busy</a> if the driver cannot be attached because the interface is claimed by a program or driver</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>This call is only effective on Linux and returns <a class="reference external" href="#LibusbError">LibusbError.notSupported</a> on all other platforms. This functionality is not available on Darwin or Windows.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1681"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetAutoDetachKernelDriver"><a name="libusbSetAutoDetachKernelDriver,ptr.LibusbDeviceHandle,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetAutoDetachKernelDriver</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">enable</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_auto_detach_kernel_driver&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
<p>Enable/disable libusb's automatic kernel driver detachment.</p>
<p>When this is enabled libusb will automatically detach the kernel driver on an interface when claiming the interface, and attach it when releasing the interface. Automatic kernel driver detachment is disabled on newly opened device handles by default.</p>
<p>On platforms which do not have <a class="reference external" href="#LibusbCapability">LibusbCapability.supportsDetachKernelDriver</a> this function will return <a class="reference external" href="#LibusbError">LibusbError.notSupported</a>, and libusb will continue as if this function was never called.</p>
<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>enable</dt>
<dd>Whether to enable or disable auto kernel driver detachment</dd>
<dt>result</dt>
<dd><ul class="simple"><li><a class="reference external" href="#LibusbError">LibusbError.success</a> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notSupported</a> on platforms where the functionality is not available.</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1707"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbControlTransferGetData"><a name="libusbControlTransferGetData,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbControlTransferGetData</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Get the data section of a control transfer.<dl class="docutils"><dt>transfer</dt>
<dd>A transfer</dd>
<dt>result</dt>
<dd>A pointer to the first byte of the data section</dd>
</dl>
<p>This convenience function is here to remind you that the data does not start until 8 bytes into the actual buffer, as the setup packet comes first. Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at <a class="reference external" href="#LibusbTransfer">transfer.buffer</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1733"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbControlTransferGetSetup"><a name="libusbControlTransferGetSetup,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbControlTransferGetSetup</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbControlSetup</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Get the control setup packet of a control transfer.<dl class="docutils"><dt>transfer</dt>
<dd>A transfer</dd>
<dt>result</dt>
<dd>A casted pointer to the start of the transfer data buffer</dd>
</dl>
<p>This convenience function is here to remind you that the control setup occupies the first 8 bytes of the transfer data buffer. Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at <a class="reference external" href="#LibusbTransfer">transfer.buffer</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1750"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillControlSetup"><a name="libusbFillControlSetup,ptr.cuchar,uint8,uint8,uint16,uint16,uint16"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillControlSetup</span><span class="Other">(</span><span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">bmRequestType</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                            <span class="Identifier">request</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                            <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfer.<dl class="docutils"><dt>buffer</dt>
<dd>Buffer to output the setup packet into. This pointer must be aligned to at least 2 bytes boundary</dd>
<dt>bmRequestType</dt>
<dd>See the <cite>bmRequestType</cite> field of <a class="reference external" href="#LibusbControlSetup">LibusbControlSetup</a></dd>
<dt>request</dt>
<dd>See the <cite>request</cite> field of <a class="reference external" href="#LibusbControlSetup">LibusbControlSetup</a></dd>
<dt>value</dt>
<dd>See the <cite>value</cite> field of <a class="reference external" href="#LibusbControlSetup">LibusbControlSetup</a></dd>
<dt>index</dt>
<dd>See the <cite>index</cite> field of <a class="reference external" href="#LibusbControlSetup">LibusbControlSetup</a></dd>
<dt>length</dt>
<dd>See the <cite>length</cite> field of <a class="reference external" href="#LibusbControlSetup">LibusbControlSetup</a></dd>
</dl>
<p>The <cite>index</cite>, <cite>value</cite> and <cite>length</cite> values should be given in host-endian byte order.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1767"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbAllocTransfer"><a name="libusbAllocTransfer,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbAllocTransfer</span><span class="Other">(</span><span class="Identifier">iso_packets</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_alloc_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Allocate a libusb transfer with a specified number of isochronous packet descriptors.<dl class="docutils"><dt>iso_packets</dt>
<dd>Number of isochronous packet descriptors to allocate</dd>
<dt>result</dt>
<dd>A newly allocated transfer, or <tt class="docutils literal"><span class="pre">nil</span></tt> on error</dd>
</dl>
<p>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <a class="reference external" href="#libusbFreeTransfer">libusbFreeTransfer</a>. Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</p>
<p>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <a class="reference external" href="#LibusbTransfer.numIsoPackets">numIsoPackets</a> and type fields accordingly.</p>
<p>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, <a class="reference external" href="#LibusbTransfer.numIsoPackets">numIsoPackets</a> is <tt class="docutils literal"><span class="pre">0</span></tt> and that type is set appropriately.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1798"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSubmitTransfer"><a name="libusbSubmitTransfer,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSubmitTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_submit_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Submit a transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to submit</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success,</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError.busy</a> if the transfer has already been submitted</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notSupported</a> if the transfer flags are not supported by the operating system</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other failures</li>
</ul>
</dd>
</dl>
<p>This function will fire off the USB transfer and then return immediately.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1826"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbCancelTransfer"><a name="libusbCancelTransfer,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbCancelTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_cancel_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Asynchronously cancel a previously submitted transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to cancel</dd>
<dt>result</dt>
<dd><ul class="simple"><li>0 on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError.notFound</a> if the transfer is already complete or cancelled</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes for other failures</li>
</ul>
</dd>
</dl>
<p>This function returns immediately, but this does not indicate cancellation is complete. Your callback function will be invoked at some later time with a transfer status of <a class="reference external" href="#LibusbTransferStatus">LibusbTransferStatus.cancelled</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1843"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFreeTransfer"><a name="libusbFreeTransfer,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFreeTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_free_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Free a transfer structure.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to free</dd>
</dl>
<p>This should be called for all transfers allocated with <a class="reference external" href="#libusbAllocTransfer">libusbAllocTransfer</a>. If the <a class="reference external" href="#LibusbTransferFlags">LibusbTransferFlags.freeBuffer</a> flag is set and the transfer buffer is not <tt class="docutils literal"><span class="pre">nil</span></tt>, this function will also free the transfer buffer using the standard system memory allocator.</p>
<p>It is legal to call this function with a <tt class="docutils literal"><span class="pre">nil</span></tt> transfer. In this case, the function will simply return safely. It is not legal to free an active transfer (one which has been submitted and has not yet completed).</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1860"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbTransferSetStreamId"><a name="libusbTransferSetStreamId,ptr.LibusbTransfer,uint32"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbTransferSetStreamId</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> <span class="Identifier">stream_id</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_transfer_set_stream_id&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Set a transfers bulk stream id.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to set the stream id for</dd>
<dt>stream_id</dt>
<dd>The stream id to set</dd>
</dl>
<p>Note users are advised to use <a class="reference external" href="#libusbFillBulkStreamTransfer">libusbFillBulkStreamTransfer</a> instead of calling this function directly.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1878"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbTransferGetStreamId"><a name="libusbTransferGetStreamId,ptr.LibusbTransfer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbTransferGetStreamId</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint32</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_transfer_get_stream_id&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Get a transfers bulk stream identifier.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to get the stream identifier for</dd>
<dt>result</dt>
<dd><ul class="simple"><li>the stream identifier for the transfer</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1893"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillControlTransfer"><a name="libusbFillControlTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,ptr.cuchar,LibusbTransferCbFn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillControlTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> 
                               <span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                               <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span><span class="Other">;</span> 
                               <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> fields for a control transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to populate</dd>
<dt>devHandle</dt>
<dd>Handle of the device that will handle the transfer</dd>
<dt>buffer</dt>
<dd>Data buffer. If provided, this function will interpret the first 8 bytes as a setup packet and infer the transfer length from that. This pointer must be aligned to at least 2 bytes boundary.</dd>
<dt>callback</dt>
<dd>Callback function to be invoked on transfer completion</dd>
<dt>userData</dt>
<dd>User data to pass to callback function</dd>
<dt>timeout</dt>
<dd>Timeout for the transfer in milliseconds</dd>
</dl>
<p>If you pass a transfer buffer to this function, the first 8 bytes will be interpreted as a control setup packet, and the <tt class="docutils literal"><span class="pre">length</span></tt> field will be used to automatically populate the <tt class="docutils literal"><span class="pre">length</span></tt> field of the transfer. Therefore the recommended approach is:</p>
<ul class="simple"><li>Allocate a suitably sized data buffer (including space for control setup)</li>
<li>Call <a class="reference external" href="#libusbFillControlSetup">libusbFillControlSetup</a></li>
<li>If this is a host-to-device transfer with a data stage, put the data in place after the setup packet</li>
<li>Call this function</li>
<li>Call <a class="reference external" href="#libusbSubmitTransfer">libusbSubmitTransfer</a></li>
</ul>
<p>It is also legal to pass a <tt class="docutils literal"><span class="pre">nil</span></tt> buffer to this function, in which case this function will not attempt to populate the length field. Remember that you must then populate the buffer and length fields later.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1903"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillBulkTransfer"><a name="libusbFillBulkTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillBulkTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> 
                            <span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                            <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                            <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span><span class="Other">;</span> <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> 
                            <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> fields for a bulk transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to populate</dd>
<dt>devHandle</dt>
<dd>Handle of the device that will handle the transfer</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint where this transfer will be sent</dd>
<dt>buffer</dt>
<dd>Data buffer</dd>
<dt>length</dt>
<dd>Length of data buffer</dd>
<dt>callback</dt>
<dd>Callback function to be invoked on transfer completion</dd>
<dt>userData</dt>
<dd>User data to pass to callback function</dd>
<dt>timeout</dt>
<dd>Timeout for the transfer in milliseconds</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1951"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillBulkStreamTransfer"><a name="libusbFillBulkStreamTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,uint32,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillBulkStreamTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> 
                                  <span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                                  <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">stream_id</span><span class="Other">:</span> <span class="Identifier">uint32</span><span class="Other">;</span> 
                                  <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                  <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span><span class="Other">;</span> 
                                  <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> fields for a bulk transfer using bulk streams.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to populate</dd>
<dt>devHandle</dt>
<dd>Handle of the device that will handle the transfer</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint where this transfer will be sent</dd>
<dt>stream_id</dt>
<dd>Bulk stream id for this transfer</dd>
<dt>buffer</dt>
<dd>Data buffer</dd>
<dt>length</dt>
<dd>Length of data buffer</dd>
<dt>callback</dt>
<dd>Callback function to be invoked on transfer completion</dd>
<dt>userData</dt>
<dd>User data to pass to callback function</dd>
<dt>timeout</dt>
<dd>Timeout for the transfer in milliseconds</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L1983"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillInterruptTransfer"><a name="libusbFillInterruptTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,LibusbTransferCbFn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillInterruptTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> 
                                 <span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                                 <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                                 <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span><span class="Other">;</span> 
                                 <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> fields for an interrupt transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to populate</dd>
<dt>devHandle</dt>
<dd>Handle of the device that will handle the transfer</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint where this transfer will be sent</dd>
<dt>buffer</dt>
<dd>Data buffer</dd>
<dt>length</dt>
<dd>Length of data buffer</dd>
<dt>callback</dt>
<dd>Callback function to be invoked on transfer completion</dd>
<dt>userData</dt>
<dd>User data to pass to callback function</dd>
<dt>timeout</dt>
<dd>Timeout for the transfer in milliseconds</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2014"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbFillIsoTransfer"><a name="libusbFillIsoTransfer,ptr.LibusbTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,cint,LibusbTransferCbFn,pointer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbFillIsoTransfer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> 
                           <span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                           <span class="Identifier">buffer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                           <span class="Identifier">numIsoPackets</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">callback</span><span class="Other">:</span> <span class="Identifier">LibusbTransferCbFn</span><span class="Other">;</span> 
                           <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">inline</span><span class="Other">,</span> 
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Helper function to populate the <a class="reference external" href="#LibusbTransfer">LibusbTransfer</a> fields for an isochronous transfer.<dl class="docutils"><dt>transfer</dt>
<dd>The transfer to populate</dd>
<dt>devHandle</dt>
<dd>Handle of the device that will handle the transfer</dd>
<dt>endpoint</dt>
<dd>Address of the endpoint where this transfer will be sent</dd>
<dt>buffer</dt>
<dd>Data buffer</dd>
<dt>length</dt>
<dd>Length of data buffer</dd>
<dt>numIsoPackets</dt>
<dd>The number of isochronous packets</dd>
<dt>callback</dt>
<dd>Callback function to be invoked on transfer completion</dd>
<dt>userData</dt>
<dd>User data to pass to callback function</dd>
<dt>timeout</dt>
<dd>Timeout for the transfer in milliseconds</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2047"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetIsoPacketLengths"><a name="libusbSetIsoPacketLengths,ptr.LibusbTransfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetIsoPacketLengths</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to set the length of all packets in an isochronous transfer, based on the numIsoPackets field in the transfer structure.<dl class="docutils"><dt>transfer</dt>
<dd>A transfer</dd>
<dt>length</dt>
<dd>The length to set in each isochronous packet descriptor (see <a class="reference external" href="#libusbGetMaxPacketSize">libusbGetMaxPacketSize</a></dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2083"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetIsoPacketBuffer"><a name="libusbGetIsoPacketBuffer,ptr.LibusbTransfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetIsoPacketBuffer</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> <span class="Identifier">packet</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer.<dl class="docutils"><dt>transfer</dt>
<dd>A transfer</dd>
<dt>packet</dt>
<dd>The packet to return the address of</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The base address of the packet buffer inside the transfer buffer</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> if the packet does not exist</li>
</ul>
</dd>
</dl>
<p>This is a thorough function which loops through all preceding packets, accumulating their lengths to find the position of the specified packet. Typically you will assign equal lengths to each packet in the transfer, and hence the above method is sub-optimal. Consider using <a class="reference external" href="#libusbGetIsoPacketBufferSimple">libusbGetIsoPacketBufferSimple</a> instead.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2100"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetIsoPacketBufferSimple"><a name="libusbGetIsoPacketBufferSimple,ptr.LibusbTransfer,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetIsoPacketBufferSimple</span><span class="Other">(</span><span class="Identifier">transfer</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbTransfer</span><span class="Other">;</span> <span class="Identifier">packet</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size.<dl class="docutils"><dt>transfer</dt>
<dd>A transfer</dd>
<dt>packet</dt>
<dd>The packet to return the address of</dd>
<dt>result</dt>
<dd><ul class="simple"><li>The base address of the packet buffer inside the transfer buffer</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> if the packet does not exist (see <a class="reference external" href="#libusbGetIsoPacketBuffer">libusbGetIsoPacketBuffer</a>).</li>
</ul>
</dd>
</dl>
<p>This function relies on the assumption that every packet within the transfer is of identical size to the first packet. Calculating the location of the packet buffer is then just a simple calculation:</p>
<blockquote><p>&lt;tt&gt;buffer + (packet_size * packet)&lt;/tt&gt;</p></blockquote>
<p>Do not use this function on transfers other than those that have identical packet lengths for each packet.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2135"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbControlTransfer"><a name="libusbControlTransfer,ptr.LibusbDeviceHandle,LibusbEndpointDirection,LibusbStandardRequest,uint16,uint16,ptr.cuchar,uint16,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbControlTransfer</span><span class="Other">(</span><span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                           <span class="Identifier">request_type</span><span class="Other">:</span> <span class="Identifier">LibusbEndpointDirection</span><span class="Other">;</span> 
                           <span class="Identifier">request</span><span class="Other">:</span> <span class="Identifier">LibusbStandardRequest</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                           <span class="Identifier">index</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> 
                           <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_control_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB control transfer.<dl class="docutils"><dt>devHandle</dt>
<dd>A handle for the device to communicate with</dd>
<dt>bmRequestType</dt>
<dd>The request type field for the setup packet</dd>
<dt>request</dt>
<dd>The request field for the setup packet</dd>
<dt>value</dt>
<dd>The value field for the setup packet</dd>
<dt>index</dt>
<dd>The index field for the setup packet</dd>
<dt>data</dt>
<dd>A suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType)</dd>
<dt>length</dt>
<dd>The length field for the setup packet. The data buffer should be at least this size</dd>
<dt>timeout</dt>
<dd>Timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use <tt class="docutils literal"><span class="pre">0</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li>on success, the number of bytes actually transferred</li>
<li><a class="reference external" href="#LibusbError">LibusbError.timeout</a> if the transfer timed out</li>
<li><a class="reference external" href="#LibusbError">LibusbError.pipe</a> if the control request was not supported by the device</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the bmRequestType field of the setup packet. The <cite>value</cite>, <cite>index</cite> and <cite>length</cite> fields values should be given in host-endian byte order.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2173"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbBulkTransfer"><a name="libusbBulkTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbBulkTransfer</span><span class="Other">(</span><span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                        <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">actualLength</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                        <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_bulk_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB bulk transfer.<dl class="docutils"><dt>devHandle</dt>
<dd>A handle for the device to communicate with</dd>
<dt>endpoint</dt>
<dd>The address of a valid endpoint to communicate with</dd>
<dt>data</dt>
<dd>A suitably-sized data buffer for either input or output(depending on endpoint)</dd>
<dt>length</dt>
<dd>For bulk writes, the number of bytes from data to be sent. For bulk reads, the maximum number of bytes to receive into the data buffer</dd>
<dt>transferred</dt>
<dd>Output location for the number of bytes actually transferred</dd>
<dt>timeout</dt>
<dd>Timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use <tt class="docutils literal"><span class="pre">0</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success (and populates transferred)</li>
<li><a class="reference external" href="#LibusbError">LibusbError.timeout</a> if the transfer timed out (and populates transferred)</li>
<li><a class="reference external" href="#LibusbError">LibusbError.pipe</a> if the endpoint halted</li>
<li><a class="reference external" href="#LibusbError">LibusbError.overflow</a> if the device offered more data, see Packets and overflows</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other failures</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the direction bits of the endpoint address. For bulk reads, the length field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the transferred output parameter.</p>
<p>You should also check the transferred parameter for bulk writes. Not all of the data may have been written. Also check transferred when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2213"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbInterruptTransfer"><a name="libusbInterruptTransfer,ptr.LibusbDeviceHandle,cuchar,ptr.cuchar,cint,ptr.cint,cuint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbInterruptTransfer</span><span class="Other">(</span><span class="Identifier">devHandle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                             <span class="Identifier">endpoint</span><span class="Other">:</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                             <span class="Identifier">actualLength</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">timeout</span><span class="Other">:</span> <span class="Identifier">cuint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_interrupt_transfer&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Perform a USB interrupt transfer.<dl class="docutils"><dt>devHandle</dt>
<dd>A handle for the device to communicate with</dd>
<dt>endpoint</dt>
<dd>The address of a valid endpoint to communicate with</dd>
<dt>data</dt>
<dd>A suitably-sized data buffer for either input or output (depending on endpoint)</dd>
<dt>length</dt>
<dd>For bulk writes, the number of bytes from data to be sent. For bulk reads, the maximum number of bytes to receive into the data buffer</dd>
<dt>actualLength</dt>
<dd>Output location for the number of bytes actually transferred</dd>
<dt>timeout</dt>
<dd>Timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use <tt class="docutils literal"><span class="pre">0</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success (and populates transferred)</li>
<li><a class="reference external" href="#LibusbError">LibusbError.timeout</a> if the transfer timed out</li>
<li><a class="reference external" href="#LibusbError">LibusbError.pipe</a> if the endpoint halted</li>
<li><a class="reference external" href="#LibusbError">LibusbError.overflow</a> if the device offered more data, see Packets and overflows</li>
<li><a class="reference external" href="#LibusbError">LibusbError.noDevice</a> if the device has been disconnected</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on other errors</li>
</ul>
</dd>
</dl>
<p>The direction of the transfer is inferred from the direction bits of the endpoint address. For interrupt reads, the length field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the transferred output parameter.</p>
<p>You should also check the transferred parameter for interrupt writes. Not all of the data may have been written. Also check transferred when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</p>
<p>The default endpoint interval value is used as the polling interval.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2260"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetDescriptor"><a name="libusbGetDescriptor,ptr.LibusbDeviceHandle,uint8,uint8,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetDescriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">desc_type</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                         <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a descriptor from the default control pipe.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>desc_type</dt>
<dd>The descriptor type, see <a class="reference external" href="#LibusbDescriptorType">LibusbDescriptorType</a></dd>
<dt>desc_index</dt>
<dd>The index of the descriptor to retrieve</dd>
<dt>data</dt>
<dd>Output buffer for descriptor</dd>
<dt>length</dt>
<dd>Size of data buffer</dd>
<dt>result</dt>
<dd><ul class="simple"><li>Number of bytes returned in data</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> code on failure</li>
</ul>
</dd>
</dl>
<p>This is a convenience function which formulates the appropriate control message to retrieve the descriptor.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2308"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetStringDescriptor"><a name="libusbGetStringDescriptor,ptr.LibusbDeviceHandle,uint8,uint16,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetStringDescriptor</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> 
                               <span class="Identifier">langid</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">inline</span><span class="Other">,</span> <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a descriptor from a device.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>desc_index</dt>
<dd>The index of the descriptor to retrieve</dd>
<dt>langid</dt>
<dd>The language ID for the string descriptor</dd>
<dt>data</dt>
<dd>Output buffer for descriptor</dd>
<dt>length</dt>
<dd>Size of data buffer</dd>
<dt>result</dt>
<dd><ul class="simple"><li>Number of bytes returned in data</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>This is a convenience function which formulates the appropriate control message to retrieve the descriptor. The string returned is Unicode, as detailed in the USB specifications.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2339"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetStringDescriptorAscii"><a name="libusbGetStringDescriptorAscii,ptr.LibusbDeviceHandle,uint8,ptr.cuchar,cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetStringDescriptorAscii</span><span class="Other">(</span><span class="Identifier">dev</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbDeviceHandle</span><span class="Other">;</span> 
                                    <span class="Identifier">desc_index</span><span class="Other">:</span> <span class="Identifier">uint8</span><span class="Other">;</span> <span class="Identifier">data</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cuchar</span><span class="Other">;</span> 
                                    <span class="Identifier">length</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_string_descriptor_ascii&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a string descriptor in C style ASCII.<dl class="docutils"><dt>dev</dt>
<dd>A device handle</dd>
<dt>desc_index</dt>
<dd>The index of the descriptor to retrieve</dd>
<dt>data</dt>
<dd>Output buffer for ASCII string descriptor</dd>
<dt>length</dt>
<dd>Size of data buffer</dd>
<dt>result</dt>
<dd><ul class="simple"><li>Number of bytes returned in data</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>Uses the first language supported by the device.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2370"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbTryLockEvents"><a name="libusbTryLockEvents,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbTryLockEvents</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_try_lock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Attempt to acquire the event handling lock. This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> if the lock was obtained successfully</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> if the lock was not obtained (i.e. another thread holds the lock)</li>
</ul>
</dd>
</dl>
<p>You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly. If you stick to libusb's event handling loop functions, i.e. <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a> then you do not need to be concerned with this locking.</p>
<p>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <a class="reference external" href="#libusbUnlockEvents">libusbUnlockEvents</a> as soon as possible.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2392"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbLockEvents"><a name="libusbLockEvents,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbLockEvents</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_lock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Acquire the event handling lock, blocking until successful acquisition if it is contended.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
</dl>
<p>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time. You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly. If you stick to libusb's event handling loop functions (e.g. <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a>) then you do not need to be concerned with this locking.</p>
<p>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <a class="reference external" href="#libusbUnlockEvents">libusbUnlockEvents</a> as soon as possible.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2414"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbUnlockEvents"><a name="libusbUnlockEvents,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbUnlockEvents</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unlock_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release the lock previously acquired with <a class="reference external" href="#libusbTryLockEvents">libusbTryLockEvents</a> or <a class="reference external" href="#libusbLockEvents">libusbLockEvents</a>.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
</dl>
<p>Releasing this lock will wake up any threads blocked on <a class="reference external" href="#libusbWaitForEvent">libusbWaitForEvent</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2434"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbEventHandlingOk"><a name="libusbEventHandlingOk,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbEventHandlingOk</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_event_handling_ok&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if it is still OK for this thread to be doing event handling.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">1</span></tt> if event handling can start or continue</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> if this thread must give up the events lock</li>
</ul>
</dd>
</dl>
<p>Sometimes, libusb needs to temporarily pause all event handlers, and this is the function you should use before polling file descriptors to see if this is the case. If this function instructs your thread to give up the events lock, you should just continue the usual logic that is documented in Multi-threaded applications and asynchronous I/O. On the next iteration, your thread will fail to obtain the events lock, and will hence become an event waiter.</p>
<p>This function should be called while the events lock is held: you don't need to worry about the results of this function if your thread is not the current event handler.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2447"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbEventHandlerActive"><a name="libusbEventHandlerActive,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbEventHandlerActive</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_event_handler_active&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine if an active thread is handling events (i.e. if anyone is holding the event handling lock).<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">1</span></tt> if a thread is handling events</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> if there are no threads currently handling events</li>
</ul>
</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2470"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbLockEventWaiters"><a name="libusbLockEventWaiters,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbLockEventWaiters</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_lock_event_waiters&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Acquire the event waiters lock.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
</dl>
<p>This lock is designed to be obtained under the situation where you want to be aware when events are completed, but some other thread is event handling so calling libusbHandleEvents() is not allowed. You then obtain this lock, re-check that another thread is still handling events, then call <a class="reference external" href="#libusbWaitForEvent">libusbWaitForEvent</a>.</p>
<p>You only need to use this lock if you are developing an application which calls <cite>poll()</cite> or <cite>select()</cite> on libusb's file descriptors directly, and may potentially be handling events from 2 threads simultaenously. If you stick to libusb's event handling loop functions (e.g. <cite>libusbHandleEvents()</cite>) then you do not need to be concerned with this locking.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2482"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbUnlockEventWaiters"><a name="libusbUnlockEventWaiters,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbUnlockEventWaiters</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_unlock_event_waiters&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Release the event waiters lock.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
</dl>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2502"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbWaitForEvent"><a name="libusbWaitForEvent,ptr.LibusbContext,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbWaitForEvent</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_wait_for_event&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Wait for another thread to signal completion of an event.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>tv</dt>
<dd>Maximum timeout for this blocking function. A <tt class="docutils literal"><span class="pre">nil</span></tt> value indicates unlimited timeout.</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> after a transfer completes or another thread stops event handling</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> if the timeout expired</li>
</ul>
</dd>
</dl>
<p>Must be called with the event waiters lock held, see <a class="reference external" href="#libusbLockEventWaiters">libusbLockEventWaiters</a>. This function will block until any of the following conditions are met:</p>
<blockquote><p><ol class="simple"><li>The timeout expires</li>
<li>A transfer completes</li>
<li>thread releases the event handling lock through <a class="reference external" href="#libusbUnlockEvents">libusbUnlockEvents</a></li>
</ol>
</p></blockquote>
<p>Condition 1 is obvious. Condition 2 unblocks your thread after the callback for the transfer has completed. Condition 3 is important because it means that the thread that was previously handling events is no longer doing so, so if any events are to complete, another thread needs to step up and start event handling.</p>
<p>This function releases the event waiters lock before putting your thread to sleep, and reacquires the lock as it is being woken up.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2510"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHandleEvents"><a name="libusbHandleEvents,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHandleEvents</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">deprecated</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events in blocking mode.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>There is currently a timeout hardcoded at 60 seconds but we plan to make it unlimited in future. For finer control over whether this function is blocking or non-blocking, or for control over the timeout, use <a class="reference external" href="#libusbHandleEventsTimeoutCompleted">libusbHandleEventsTimeoutCompleted</a> instead.</p>
<p>This function is kept primarily for backwards compatibility. Use <a class="reference external" href="#libusbHandleEventsCompleted">libusbHandleEventsCompleted</a> or <a class="reference external" href="#libusbHandleEventsTimeoutCompleted">libusbHandleEventsTimeoutCompleted</a> to avoid race conditions.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2542"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHandleEventsTimeoutCompleted"><a name="libusbHandleEventsTimeoutCompleted,ptr.LibusbContext,ptr.timeval,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHandleEventsTimeoutCompleted</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">;</span> 
                                        <span class="Identifier">completed</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_timeout_completed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>tv</dt>
<dd>The maximum time to block waiting for events, or an all zero timeval struct for non-blocking mode</dd>
<dt>completed</dt>
<dd>Pointer to completion integer to check, or <tt class="docutils literal"><span class="pre">nil</span></tt></dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>libusb determines &quot;pending events&quot; by checking if any timeouts have expired and by checking the set of file descriptors for activity.</p>
<p>If a zero timeval is passed, this function will handle any already-pending events and then immediately return in non-blocking style. If a non-zero timeval is passed and no events are currently pending, this function will block waiting for events to handle up until the specified timeout.</p>
<p>If an event arrives or a signal is raised, this function will return early. If the parameter completed is not <tt class="docutils literal"><span class="pre">nil</span></tt> then after obtaining the event handling lock this function will return immediately if the integer pointed to is not <tt class="docutils literal"><span class="pre">0</span></tt>. This allows for race free waiting for the completion of a specific transfer.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2564"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHandleEventsCompleted"><a name="libusbHandleEventsCompleted,ptr.LibusbContext,ptr.cint"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHandleEventsCompleted</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">completed</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">cint</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_completed&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events in blocking mode.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>completed</dt>
<dd>Pointer to completion integer to check, or nil</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codec on failure</li>
</ul>
</dd>
</dl>
<p>Like <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a>, with the addition of a completed parameter to allow for race free waiting for the completion of a specific transfer. See <a class="reference external" href="#libusbHandleEventsTimeoutCompleted">libusbHandleEventsTimeoutCompleted</a> for details on the completed parameter.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2595"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHandleEventsLocked"><a name="libusbHandleEventsLocked,ptr.LibusbContext,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHandleEventsLocked</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_handle_events_locked&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Handle any pending events by polling file descriptors, without checking if any other threads are already doing so.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>tv</dt>
<dd>The maximum time to block waiting for events, or zero for non-blocking mode</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>Must be called with the event lock held, see <a class="reference external" href="#libusbLockEvents">libusbLockEvents</a>. This function is designed to be called under the situation where you have taken the event lock and are calling <cite>poll()/select()</cite> directly on libusb's file descriptors (as opposed to using <cite>libusbHandleEventsXXX</cite> or similar). You detect events on libusb's descriptors, so you then call this function with a zero timeout value (while still holding the event lock).</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2614"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbPollfdsHandleTimeouts"><a name="libusbPollfdsHandleTimeouts,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbPollfdsHandleTimeouts</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_pollfds_handle_timeouts&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determines whether your application must apply special timing considerations when monitoring libusb's file descriptors.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> if you must call into libusb at times determined by <a class="reference external" href="#libusbGetNextTimeout">libusbGetNextTimeout</a></li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> if all timeout events are handled internally or through regular activity on the file descriptors</li>
</ul>
</dd>
</dl>
<p>This function is only useful for applications which retrieve and poll libusb's file descriptors in their own main loop (The more advanced option). Ordinarily, libusb's event handler needs to be called into at specific moments in time (in addition to times when there is activity on the file descriptor set).</p>
<p>The usual approach is to use <a class="reference external" href="#libusbGetNextTimeout">libusbGetNextTimeout</a> to learn about when the next timeout occurs, and to adjust your <cite>poll() / select()</cite> timeout accordingly so that you can make a call into the library at that time.</p>
<p>Some platforms supported by libusb do not come with this baggage - any events relevant to timing will be represented by activity on the file descriptor set, and <a class="reference external" href="#libusbGetNextTimeout">libusbGetNextTimeout</a> will always return <tt class="docutils literal"><span class="pre">0</span></tt>. This function allows you to detect whether you are running on such a platform.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2637"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetNextTimeout"><a name="libusbGetNextTimeout,ptr.LibusbContext,ptr.timeval"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetNextTimeout</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> <span class="Identifier">tv</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">timeval</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_next_timeout&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Determine the next internal timeout that libusb needs to handle.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>tv</dt>
<dd>Output location for a relative time against the current clock in which libusb must be called into in order to process timeout events</dd>
<dt>result</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">0</span></tt> if there are no pending timeouts</li>
<li><tt class="docutils literal"><span class="pre">1</span></tt> if a timeout was returned</li>
<li><a class="reference external" href="#LibusbError">LibusbError.other</a> on failure</li>
</ul>
</dd>
</dl>
<p>You only need to use this function if you are calling <cite>poll()</cite> or <cite>select()</cite> or similar on libusb's file descriptors yourself. You do not need to use it if you are calling <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a> or a variant directly.</p>
<p>You should call this function in your main loop in order to determine how long to wait for select() or poll() to return results. libusb needs to be called into at this timeout, so you should use it as an upper bound on your <cite>select()</cite> or <cite>poll()</cite> call.</p>
<p>When the timeout has expired, call into <cite>libusb_handle_events_timeout()</cite> (perhaps in non-blocking mode) so that libusb can handle the timeout.</p>
<p>This function may return <tt class="docutils literal"><span class="pre">1</span></tt> (success) and an all-zero timeval. If this is the case, it indicates that libusb has a timeout that has already expired so you should call libusb_handle_events_timeout() or similar immediately. A return code of <tt class="docutils literal"><span class="pre">0</span></tt> indicates that there are no pending timeouts.</p>
<p>On some platforms, this function will always returns <tt class="docutils literal"><span class="pre">0</span></tt> (no pending timeouts). See Notes on time-based events.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2668"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbGetPollfds"><a name="libusbGetPollfds,ptr.LibusbContext"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbGetPollfds</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbPollfd</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> 
    <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_get_pollfds&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>result</dt>
<dd><ul class="simple"><li>NULL-terminated list of <a class="reference external" href="#LibusbPollfd">LibusbPollfd</a> structures</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> on error</li>
<li><tt class="docutils literal"><span class="pre">nil</span></tt> on platforms where the functionality is not available</li>
</ul>
</dd>
</dl>
<p>The returned list is NULL-terminated and should be freed with <cite>free()</cite> when done. The actual list contents must not be touched. As file descriptors are a Unix-specific concept, this function is not available on Windows and will always return <tt class="docutils literal"><span class="pre">nil</span></tt>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2742"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbSetPollfdNotifiers"><a name="libusbSetPollfdNotifiers,ptr.LibusbContext,LibusbPollfdAddedCb,LibusbPollfdRemovedCb,pointer"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbSetPollfdNotifiers</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
                              <span class="Identifier">added_cb</span><span class="Other">:</span> <span class="Identifier">LibusbPollfdAddedCb</span><span class="Other">;</span> 
                              <span class="Identifier">removed_cb</span><span class="Other">:</span> <span class="Identifier">LibusbPollfdRemovedCb</span><span class="Other">;</span> 
                              <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">)</span> <span class="Other">{.</span><span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> 
    <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_set_pollfd_notifiers&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Register notification functions for file descriptor additions/removals.<dl class="docutils"><dt>ctx</dt>
<dd>The context to operate on, or <tt class="docutils literal"><span class="pre">nil</span></tt> for the default context</dd>
<dt>added_cb</dt>
<dd>Pointer to function for addition notifications</dd>
<dt>removed_cb</dt>
<dd>Pointer to function for removal notifications</dd>
<dt>userData</dt>
<dd>User data to be passed back to callbacks (useful for passing context information)</dd>
</dl>
<p>These functions will be invoked for every new or removed file descriptor that libusb uses as an event source. To remove notifiers, pass <tt class="docutils literal"><span class="pre">nil</span></tt> values for the function pointers.</p>
<p>Note that file descriptors may have been added even before you register these notifiers (e.g. at <a class="reference external" href="#libusbInit">libusbInit</a> time). Additionally, note that the removal notifier may be called during <a class="reference external" href="#libusbExit">libusbExit</a> (e.g. when it is closing file descriptors that were opened and added to the poll set at <a class="reference external" href="#libusbInit">libusbInit</a> time). If you don't want this, remove the notifiers immediately before calling <a class="reference external" href="#libusbExit">libusbExit</a>.</p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2760"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHotplugRegisterCallback"><a name="libusbHotplugRegisterCallback,ptr.LibusbContext,LibusbHotplugEvent,LibusbHotplugFlag,cint,cint,cint,LibusbHotplugCallbackFn,pointer,ptr.LibusbHotplugCallbackHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHotplugRegisterCallback</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
                                   <span class="Identifier">events</span><span class="Other">:</span> <span class="Identifier">LibusbHotplugEvent</span><span class="Other">;</span> 
                                   <span class="Identifier">flags</span><span class="Other">:</span> <span class="Identifier">LibusbHotplugFlag</span><span class="Other">;</span> <span class="Identifier">vendor_id</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                   <span class="Identifier">product_id</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> <span class="Identifier">dev_class</span><span class="Other">:</span> <span class="Identifier">cint</span><span class="Other">;</span> 
                                   <span class="Identifier">cb_fn</span><span class="Other">:</span> <span class="Identifier">LibusbHotplugCallbackFn</span><span class="Other">;</span> 
                                   <span class="Identifier">userData</span><span class="Other">:</span> <span class="Identifier">pointer</span><span class="Other">;</span> 
                                   <span class="Identifier">handle</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbHotplugCallbackHandle</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">cint</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_hotplug_register_callback&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
Register a hotplug callback function.<dl class="docutils"><dt>ctx</dt>
<dd>Context to register this callback with</dd>
<dt>events</dt>
<dd>Bitwise or of events that will trigger this callback (see <a class="reference external" href="#LibusbHotplugEvent">LibusbHotplugEvent</a>)</dd>
<dt>flags</dt>
<dd>Hotplug callback flags (see <cite>LibusbHotplugFlag</cite>)</dd>
<dt>vendor_id</dt>
<dd>The vendor id to match, or <a class="reference external" href="#libusbHotplugMatchAny">libusbHotplugMatchAny</a></dd>
<dt>product_id</dt>
<dd>The product id to match, or <a class="reference external" href="#libusbHotplugMatchAny">libusbHotplugMatchAny</a></dd>
<dt>dev_class</dt>
<dd>The device class to match, or <a class="reference external" href="#libusbHotplugMatchAny">libusbHotplugMatchAny</a></dd>
<dt>cb_fn</dt>
<dd>The function to be invoked on a matching event/device</dd>
<dt>userData</dt>
<dd>User data to pass to the callback function</dd>
<dt>handle</dt>
<dd>Pointer to store the handle of the allocated callback (can be <tt class="docutils literal"><span class="pre">nil</span></tt>).</dd>
<dt>result</dt>
<dd><ul class="simple"><li><a class="reference external" href="#LibusbError">LibusbError.success</a> on success</li>
<li><a class="reference external" href="#LibusbError">LibusbError</a> codes on failure</li>
</ul>
</dd>
</dl>
<p>The callback will fire when a matching event occurs on a matching device. It is active until either it is deregistered with <a class="reference external" href="#libusbHotplugDeregisterCallback">libusbHotplugDeregisterCallback</a> or the supplied callback returns <tt class="docutils literal"><span class="pre">1</span></tt> to indicate that it is finished processing events. If the <a class="reference external" href="#LibusbHotplugFlag">LibusbHotplugFlag.enumerate</a> flag is passed, the callback will be called with <a class="reference external" href="#LibusbHotplugEvent">LibusbHotplugEvent.deviceArrived</a> for all devices already plugged into the machine.</p>
<p>Note that libusb modifies its internal device list from a separate thread, while calling hotplug callbacks from <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a>, so it is possible for a device to already be present on, or removed from, its internal device list, while the hotplug callbacks still need to be dispatched. This means that, when using <a class="reference external" href="#LibusbHotplugFlag">LibusbHotplugFlag.enumerate</a>, your callback may be called twice for the arrival of the same device, once from <a class="reference external" href="#libusbHotplugRegisterCallback">libusbHotplugRegisterCallback</a> and once from <a class="reference external" href="#libusbHandleEvents">libusbHandleEvents</a>; and/or your callback may be called for the removal of a device for which an arrived call was never made.</p>
<p>See also <a class="reference external" href="#libusbHotplugDeregisterCallback">libusbHotplugDeregisterCallback</a></p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2854"
class="link-seesrc" target="_blank">Source</a>
</dd>
<dt id="libusbHotplugDeregisterCallback"><a name="libusbHotplugDeregisterCallback,ptr.LibusbContext,LibusbHotplugCallbackHandle"></a><pre><span class="Keyword">proc</span> <span class="Identifier">libusbHotplugDeregisterCallback</span><span class="Other">(</span><span class="Identifier">ctx</span><span class="Other">:</span> <span class="Keyword">ptr</span> <span class="Identifier">LibusbContext</span><span class="Other">;</span> 
                                     <span class="Identifier">handle</span><span class="Other">:</span> <span class="Identifier">LibusbHotplugCallbackHandle</span><span class="Other">)</span> <span class="Other">{.</span>
    <span class="Identifier">cdecl</span><span class="Other">,</span> <span class="Identifier">dynlib</span><span class="Other">:</span> <span class="Identifier">dllname</span><span class="Other">,</span> <span class="Identifier">importc</span><span class="Other">:</span> <span class="StringLit">&quot;libusb_hotplug_deregister_callback&quot;</span><span class="Other">.}</span></pre></dt>
<dd>
De-register a hotplug callback.<dl class="docutils"><dt>ctx</dt>
<dd>The context that this callback is registered with</dd>
<dt>handle</dt>
<dd>The handle of the callback to deregister</dd>
</dl>
<p>Deregister a callback from a <a class="reference external" href="#LibusbContext">LibusbContext</a>. This function is safe to call from within a hotplug callback.</p>
<p>See also <a class="reference external" href="#libusbHotplugRegisterCallback">libusbHotplugRegisterCallback</a></p>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L2912"
class="link-seesrc" target="_blank">Source</a>
</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<dt id="libusbLe16ToCpu"><a name="libusbLe16ToCpu.t,uint16"></a><pre><span class="Keyword">template</span> <span class="Identifier">libusbLe16ToCpu</span><span class="Other">(</span><span class="Identifier">x</span><span class="Other">:</span> <span class="Identifier">uint16</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">uint16</span></pre></dt>
<dd>

&nbsp;&nbsp;<a
href="https://github.com/nimious/io-usb/tree/master/src/libusb.nim#L49"
class="link-seesrc" target="_blank">Source</a>
</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small>Made with Nim. Generated: 2015-01-31 00:03:48 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
